# 线上项目包装完整方案

## 一、项目背景（必须一致）

### 1.1 公司背景

**公司名称**：可以说是一个**餐饮 SaaS 平台**（类似美团、饿了么的商家端）

**业务模式**：
- B2B SaaS 平台，为餐饮商家提供 POS、商品管理、订单管理等服务
- 主要客户：中小型餐饮连锁（1-100 家门店）
- 日订单量：50-80 万单（全平台）

**你的角色**：
- 后端开发工程师
- 负责库存管理模块的架构设计和核心功能开发
- 团队规模：5-8 人（后端 3-4 人，前端 2-3 人，测试 1 人）

---

### 1.2 项目背景

**项目名称**：库存管理系统（订单系统的核心模块）

**业务背景**：
- 平台有大量餐饮商家，需要管理商品库存
- 支持多端（POS、Kiosk、Online Order）下单
- 需要保证库存一致性，防止超卖

**项目规模**：
- 日订单量：50-80 万单（全平台）
- 商品数量：10 万+ SKU
- 门店数量：1-2 万家
- 并发峰值：1000+ QPS

**上线时间**：
- 一期开发周期：3 个月
- 一期上线时间：2024 年 Q2
- 二期开发周期：2 个月（商品中心与POS库存同步）
- 二期上线时间：2024 年 Q4
- 目前状态：已上线，稳定运行

---

### 1.3 项目演进

**一期功能**（2024 Q2）：
- 库存锁定、扣减、解锁
- 订单服务与商品服务的库存同步
- 防超卖、幂等性保证

**二期功能**（2024 Q4）：
- **商品中心与POS库存同步**（新增）
- 渠道维度库存管理（POS、KIOSK、ONLINE_ORDER）
- 自动恢复库存（次日自动恢复、指定时间恢复）
- 库存变动记录查询

---

## 二、技术架构（必须真实）

### 2.1 技术栈

**后端**：
- Java 8+、Spring Boot、MyBatis
- MySQL 8.0（分库分表：ShardingSphere）
- Redis（缓存、分布式锁）
- RocketMQ（消息队列）
- Outbox 模式（消息可靠投递）

**基础设施**：
- 阿里云/腾讯云
- Docker + K8s
- 监控：Prometheus + Grafana

---

### 2.2 系统架构

> 详细架构图见 [系统架构图.md](系统架构图.md)

```
┌─────────────────────────────────────────────────────────────┐
│                     门店（局域网）                            │
│                                                             │
│    Kiosk ──┐                                                │
│    eMenu ──┼──→ POS（门店中枢，本地DB）                      │
│    KDS   ──┘        │                                       │
└─────────────────────┼───────────────────────────────────────┘
                      │ 互联网（可能断网）
                      │ MQ 双向同步
┌─────────────────────┼───────────────────────────────────────┐
│                     ↓            云端                        │
│                                                             │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐            │
│  │  订单服务   │  │  商品中心   │  │  OO 在线    │            │
│  │            │→ │  (库存同步) │ ←│  点餐       │            │
│  └─────┬──────┘  └─────┬──────┘  └────────────┘            │
│        │               │                                    │
│        ↓               ↓                                    │
│  ┌──────────────────────────────────────────┐               │
│  │  MySQL 分库分表 (2库×4表)  │  Redis 缓存   │               │
│  │  ShardingSphere           │  Cache-Aside  │               │
│  │  虚拟桶 1024              │              │               │
│  └──────────────────────────────────────────┘               │
│  ┌──────────────────────────────────────────┐               │
│  │  RocketMQ 消息总线  │  Outbox 可靠投递    │               │
│  └──────────────────────────────────────────┘               │
└─────────────────────────────────────────────────────────────┘
```

**分库分表**：
- 分片键：`product_shard_id`（由 `store_id` 经 Murmur3 Hash → 0~1023 虚拟桶）
- 2 个数据库 × 4 张表/库 = 8 张物理表
- 同一门店的商品、SKU、库存、交易记录在同一分片（数据共置）
- 使用 ShardingSphere 做分库分表

**二期新增**：
- POS 作为门店中枢，Kiosk/eMenu/KDS 走局域网连 POS
- 商品中心与 POS 库存双向同步（Outbox + MQ）
- 渠道维度库存管理（POS、OO，含共享池 + 加权分配）
- 自动恢复库存（定时任务）
- POS 离线事件回放 + 超卖检测

---

## 三、核心功能（必须真实）

### 3.1 库存锁定（下单时）

**业务场景**：
- 用户下单时，先锁定库存
- 锁定成功才能创建订单
- 锁定失败返回"库存不足"

**技术实现**：
- 数据库行锁：`UPDATE inventory SET locked_stock = locked_stock + ? WHERE ...`
- 幂等性：唯一索引 `(order_id, sku_id)` 防止重复锁定

**性能数据**：
- 平均响应时间：< 50ms
- P99 响应时间：< 200ms

---

### 3.2 库存扣减（支付后）

**业务场景**：
- 支付成功后，扣减库存
- 扣减成功才能完成订单
- 扣减失败需要退款

**技术实现**：
- CAS 更新：从 LOCKED 状态转为 DEDUCTED
- 数据库行锁：`UPDATE inventory SET current_stock = current_stock - ?, locked_stock = locked_stock - ? WHERE ...`
- 幂等性：唯一索引 `(order_id, sku_id)` 防止重复扣减

**性能数据**：
- 平均响应时间：< 100ms
- P99 响应时间：< 300ms

---

### 3.3 库存解锁（取消时）

**业务场景**：
- 订单取消时，解锁库存
- 解锁成功才能退款
- 解锁失败需要人工处理

**技术实现**：
- CAS 更新：从 LOCKED 状态转为 UNLOCKED
- 数据库行锁：`UPDATE inventory SET locked_stock = locked_stock - ? WHERE ...`
- 幂等性：唯一索引 `(order_id, sku_id)` 防止重复解锁

**性能数据**：
- 平均响应时间：< 100ms
- P99 响应时间：< 300ms

---

### 3.4 商品中心与POS库存同步（二期新增）

**业务场景**：
- POS 端操作库存（可售/售罄/库存限制），需要同步到商品中心
- 商品中心后台设置库存，需要同步到 POS
- 目标：自有渠道≤3s，三方≤10s

**技术实现**：
- **接收POS上报**：POS 调用接口上报库存变更，使用 `updated_at` 做乐观锁
- **下发至POS**：商品中心变更通过 RocketMQ 推送给 POS
- **Outbox 模式**：保证消息可靠投递
- **补偿机制**：定时任务扫描未同步的变更

**数据库设计**：
```sql
-- 库存主表
CREATE TABLE poi_item_stock (
    id BIGINT PRIMARY KEY,
    brand_id VARCHAR(32),
    poi_id VARCHAR(32),
    object_id BIGINT,
    stock_status INT,  -- 1:可售, 2:售罄
    stock_type INT,    -- 1:不限量, 2:限量
    plan_quantity DECIMAL(10,1),
    real_quantity DECIMAL(10,1),
    auto_restore_type INT,
    auto_restore_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ,
    UNIQUE KEY uk_brand_poi_object (brand_id, poi_id, id)
);

-- 渠道库存表
CREATE TABLE poi_item_channel_stock (
    id BIGINT PRIMARY KEY,
    brand_id VARCHAR(32),
    poi_id VARCHAR(32),
    stock_id BIGINT,
    channel_code VARCHAR(32),  -- POS, KIOSK, ONLINE_ORDER
    stock_status INT,
    stock_type INT,
    UNIQUE KEY uk_brand_poi_id (brand_id, poi_id, id)
);

-- 库存变更记录表
CREATE TABLE poi_item_stock_log (
    id BIGINT PRIMARY KEY,
    brand_id VARCHAR(32),
    poi_id VARCHAR(32),
    stock_id BIGINT,
    content TEXT,  -- JSON格式，记录变更内容
    created_at TIMESTAMPTZ
);
```

**性能数据**：
- 消息同步延迟：< 3s（自有渠道），< 10s（三方渠道）
- 接口响应时间：< 100ms
- 数据一致性：99.99%

---

### 3.5 渠道维度库存管理（二期新增）

**业务场景**：
- 支持按渠道（POS、KIOSK、ONLINE_ORDER）设置库存状态
- POS 渠道售罄，但 KIOSK 渠道可售
- 如何防止超卖？

**技术实现**：
- **共享库存 + 渠道状态独立**：
  - `poi_item_stock` 表存储总库存（所有渠道共享）
  - `poi_item_channel_stock` 表存储渠道状态（每个渠道独立）
- **扣减逻辑**：
  - 扣减时检查总库存和渠道状态
  - 实际可扣减数量 = min(总库存可用, 渠道限制可用)
- **并发控制**：
  - 分布式锁 + 数据库行锁 + WHERE 条件

**性能数据**：
- 超卖率：< 0.01%
- 并发处理能力：1000+ QPS

---

### 3.6 自动恢复库存（二期新增）

**业务场景**：
- 支持"次日自动恢复"、"指定时间恢复"
- 如何保证定时任务可靠执行？

**技术实现**：
- **定时任务扫描**：
  - 每天凌晨扫描"次日恢复"的库存
  - 每分钟扫描"指定时间恢复"的库存
- **延迟队列**：
  - 设置恢复时间时，发送延迟消息到 RocketMQ
- **任务持久化**：
  - 恢复任务写入数据库，服务重启后重新加载

**性能数据**：
- 恢复任务执行成功率：> 99.9%
- 恢复时间误差：< 1 分钟

---

## 四、技术难点（必须真实）

### 4.1 分布式一致性（最高难度）- 一期

**问题描述**：
- 订单服务和商品服务需要实时同步库存状态
- 使用 Outbox 模式保证消息可靠投递

**技术实现**：
- 库存扣减时，先写入 outbox 表（本地事务）
- 定时任务扫描 outbox，发送消息到商品服务
- 商品服务消费消息，更新库存

**遇到的问题**：
- **问题1**：OutboxCleanupTask 只扫描 shard_id 0-9，但实际 shard_id 范围是 0-1023
- **影响**：大部分失败任务永远不会被重试
- **修复**：按实际 shard_id 范围扫描，修复后所有失败任务都能重试

**性能数据**：
- 消息同步延迟：< 3s（自有渠道），< 10s（三方渠道）
- 消息丢失率：< 0.01%

---

### 4.2 并发控制（高难度）

**问题描述**：
- 支付成功扣减（deduct）和取消解锁（unlock）可能并发执行
- 如何防止已解锁的库存又被扣减？

**初始方案**：
- 只用了乐观锁（`updated_at`）
- 但发现高并发场景下不够，可能导致 locked_stock 为负数

**改进方案**：
- 改为 CAS 更新：从 LOCKED 状态转为 DEDUCTED/UNLOCKED
- 唯一索引改为 `(order_id, sku_id)`，只允许一条记录
- 使用状态机，保证只有一个操作能成功

**遇到的问题**：
- **问题1**：线上出现 locked_stock 为负数的情况
- **排查**：通过日志定位到是重复解锁导致的
- **修复**：改为 CAS 更新，修复后不再出现负数

**性能数据**：
- 并发冲突率：< 0.1%
- 数据一致性：99.99%

---

### 4.3 防超卖（高频面试题）

**问题描述**：
- 多端同时扣减库存，如何防止超卖？

**技术实现**：
- 数据库 WHERE 条件：`WHERE locked_stock >= quantity`
- Redis 预扣减（高并发场景）：Lua 脚本保证原子性
- 分布式锁：扣减前先获取锁

**三层防护**：
1. Redis 预扣减（快速响应，< 10ms）
2. 数据库行锁（保证原子性）
3. WHERE 条件（防止超卖）

**性能数据**：
- 超卖率：< 0.01%
- 并发处理能力：1000+ QPS

---

### 4.4 商品中心与POS库存同步（二期新增，最高难度）

**问题描述**：
- 商品中心与POS需要实时同步库存状态
- 目标：自有渠道≤3s，三方≤10s
- 如何保证数据一致性？

**技术挑战**：
```
场景1：商品中心设置售罄，POS同时扣减库存
  → 两个操作同时发生，如何保证一致性？

场景2：POS上报库存变更，但网络延迟
  → 商品中心已更新，但POS没收到确认
  → POS重试上报，如何处理？

场景3：商品中心下发库存变更，但POS没收到
  → 如何保证最终一致性？
```

**技术实现**：
- **Outbox 模式**：保证库存变更消息的可靠投递
- **消息队列**：商品中心变更通过 RocketMQ 推送给 POS
- **补偿机制**：定时任务扫描未同步的变更，补偿失败的消息
- **对账机制**：定期校验商品中心和 POS 的数据一致性
- **乐观锁**：使用 `updated_at` 做乐观锁，防止并发覆盖

**遇到的问题**：
- **问题1**：原设计只用了乐观锁（`updated_at`），高并发场景下不够
- **改进**：增加分布式锁，更新前先获取锁
- **问题2**：消息同步可能失败，导致数据不一致
- **改进**：增加补偿机制，定时任务扫描未同步的变更

**性能数据**：
- 消息同步延迟：< 3s（自有渠道），< 10s（三方渠道）
- 消息丢失率：< 0.01%
- 数据一致性：99.99%

---

### 4.5 渠道库存隔离（二期新增，高难度）

**问题描述**：
- 支持按渠道（POS、KIOSK、ONLINE_ORDER）设置库存状态
- POS 设置库存限制 10 份，KIOSK 设置 10 份，总库存 15 份
- 如何防止超卖？如何保证公平分配？

**技术实现**：
- **共享库存 + 渠道状态独立**：
  - 总库存共享：所有渠道共享总库存
  - 渠道状态独立：每个渠道可以独立设置状态
- **扣减逻辑**：
  - 扣减时检查总库存和渠道库存限制
  - 实际可扣减数量 = min(总库存可用, 渠道限制可用)
- **并发控制**：
  - 分布式锁 + 数据库行锁 + WHERE 条件

**遇到的问题**：
- **问题1**：如何防止超卖？
  - 解决：检查总库存和渠道限制，取最小值
- **问题2**：如何保证公平分配？
  - 解决：预留库存机制，每个渠道预留一定库存

**性能数据**：
- 超卖率：< 0.01%
- 并发处理能力：1000+ QPS

---

## 五、线上问题（必须真实）

### 5.1 问题1：locked_stock 为负数

**问题描述**：
- 线上某热门商品，`locked_stock` 出现负数
- 影响：部分订单无法正常处理

**排查过程**：
1. 查看日志，定位到变成负数的那次操作
2. 发现是重复解锁导致的
3. 检查代码，发现只用了乐观锁，高并发场景下不够

**解决方案**：
- 改为 CAS 更新：从 LOCKED 状态转为 DEDUCTED/UNLOCKED
- 唯一索引改为 `(order_id, sku_id)`，用状态机保证互斥
- 修复后不再出现负数

**影响范围**：
- 影响订单数：< 100 单
- 处理时间：2 小时
- 修复后：不再出现

---

### 5.2 问题2：扫描范围 bug

**问题描述**：
- OutboxCleanupTask 只扫描 shard_id 0-9，但实际 shard_id 范围是 0-1023
- 影响：大部分失败任务永远不会被重试

**排查过程**：
1. 监控发现部分失败任务一直不重试
2. 检查代码，发现扫描范围不对
3. 修复扫描范围

**解决方案**：
- 修复扫描范围，按实际 shard_id 范围扫描
- 修复后所有失败任务都能重试

**影响范围**：
- 影响任务数：< 1000 个
- 处理时间：1 小时
- 修复后：所有任务都能重试

---

### 5.3 问题3：去重键问题

**问题描述**：
- 商品服务 CREATE/UPDATE/DELETE 都用同一个 type，导致后续更新丢失
- 影响：商品更新后，缓存不更新

**排查过程**：
1. 发现商品更新后，缓存不更新
2. 检查 outbox 表，发现后续更新记录没有写入
3. 检查代码，发现唯一索引冲突

**解决方案**：
- 改为 `(order_id, sku_id)` 唯一索引，用 CAS 更新做状态机
- 修复后所有更新都能正常写入

**影响范围**：
- 影响商品数：< 50 个
- 处理时间：1 小时
- 修复后：所有更新都能正常写入

---

### 5.4 问题4：商品中心与POS同步延迟（二期）

**问题描述**：
- 商品中心设置库存，但POS延迟收到消息（> 10s）
- 影响：POS端显示库存不一致

**排查过程**：
1. 监控发现消息同步延迟
2. 检查消息队列，发现消息堆积
3. 检查消费者，发现消费速度慢

**解决方案**：
- 优化消费者，增加并发数
- 增加补偿机制，定时任务扫描未同步的变更
- 修复后消息同步延迟 < 3s

**影响范围**：
- 影响门店数：< 100 家
- 处理时间：4 小时
- 修复后：消息同步延迟 < 3s

---

### 5.5 问题5：渠道库存超卖（二期）

**问题描述**：
- 某热门商品，POS 和 KIOSK 同时扣减，导致总库存超卖
- 影响：部分订单无法正常处理

**排查过程**：
1. 监控发现超卖订单
2. 检查扣减逻辑，发现只检查了渠道限制，没检查总库存
3. 修复扣减逻辑

**解决方案**：
- 扣减时检查总库存和渠道限制，取最小值
- 增加分布式锁，防止并发冲突
- 修复后不再出现超卖

**影响范围**：
- 影响订单数：< 50 单
- 处理时间：2 小时
- 修复后：不再出现超卖

---

## 六、性能数据（必须合理）

### 6.1 系统性能

| 指标 | 数值 | 说明 |
|-----|------|------|
| **日订单量** | 50-80 万单 | 全平台 |
| **并发峰值** | 1000+ QPS | 库存扣减接口 |
| **平均响应时间** | < 100ms | 库存扣减接口 |
| **P99 响应时间** | < 300ms | 库存扣减接口 |
| **消息同步延迟** | < 3s | 自有渠道 |
| **消息丢失率** | < 0.01% | Outbox 消息 |
| **超卖率** | < 0.01% | 库存扣减 |
| **数据一致性** | 99.99% | 多端同步 |

---

### 6.2 数据库性能

| 指标 | 数值 | 说明 |
|-----|------|------|
| **数据库数量** | 3 个库 | 按 store_id 分库 |
| **单库表数量** | 32 张表 | 按 product_id 分表 |
| **单表数据量** | < 100 万 | 库存主表 |
| **单表 QPS** | < 500 | 库存扣减接口 |
| **索引命中率** | > 99% | 主要查询 |

---

## 七、团队协作（必须真实）

### 7.1 团队结构

**后端团队**（3-4 人）：
- 你：负责库存管理模块
- 同事A：负责订单服务
- 同事B：负责商品服务
- 同事C：负责支付服务

**前端团队**（2-3 人）：
- 负责 POS 端、后台管理端

**测试团队**（1 人）：
- 负责功能测试、性能测试

---

### 7.2 协作流程

**开发流程**：
1. 需求评审（产品、开发、测试）
2. 技术方案设计（你负责）
3. 代码开发（你负责核心模块）
4. Code Review（团队 review）
5. 测试（测试团队）
6. 上线（运维团队）

**技术方案评审**：
- 你负责技术方案设计
- 团队 review 后确定方案
- 你负责核心功能开发

---

## 八、二期功能详细设计（商品中心与POS库存同步）

### 8.1 数据库设计

#### 8.1.1 库存主表（poi_item_stock）

```sql
CREATE TABLE poi_item_stock (
    id BIGINT PRIMARY KEY,
    brand_id VARCHAR(32) NOT NULL,
    poi_id VARCHAR(32) NOT NULL,
    object_type INT NOT NULL,  -- 1:SPU, 2:SKU
    object_id BIGINT NOT NULL,
    stock_status INT NOT NULL,  -- 1:可售, 2:售罄
    stock_type INT DEFAULT 0,    -- 1:不限量, 2:限量
    plan_quantity DECIMAL(10,1) DEFAULT 0,  -- 计划库存份数
    real_quantity DECIMAL(10,1) DEFAULT 0,  -- 实时库存
    auto_restore_type INT DEFAULT 0,  -- 1:自动恢复, 2:不自动恢复
    auto_restore_at TIMESTAMPTZ,  -- 恢复时间
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE KEY uk_brand_poi_object (brand_id, poi_id, id)
);
```

#### 8.1.2 渠道库存表（poi_item_channel_stock）

```sql
CREATE TABLE poi_item_channel_stock (
    id BIGINT PRIMARY KEY,
    brand_id VARCHAR(32) NOT NULL,
    poi_id VARCHAR(32) NOT NULL,
    stock_id BIGINT NOT NULL,  -- 关联 poi_item_stock.id
    channel_code VARCHAR(32) NOT NULL,  -- POS, KIOSK, ONLINE_ORDER
    stock_status INT NOT NULL,  -- 1:可售, 2:售罄
    stock_type INT DEFAULT 0,    -- 1:不限量, 2:共享限量
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE KEY uk_brand_poi_id (brand_id, poi_id, id)
);
```

#### 8.1.3 库存变更记录表（poi_item_stock_log）

```sql
CREATE TABLE poi_item_stock_log (
    id BIGINT PRIMARY KEY,
    brand_id VARCHAR(32) NOT NULL,
    poi_id VARCHAR(32) NOT NULL,
    stock_id BIGINT NOT NULL,
    content TEXT NOT NULL,  -- JSON格式，记录变更内容
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

---

### 8.2 API 设计

#### 8.2.1 接收POS库存变更（sync-from-pos）

**接口**：`POST /api/v1/poi/stock/sync-from-pos`

**请求体**：
```json
{
    "brandId": "1",
    "poiId": "1",
    "object_id": 1,
    "stock_status": 1,
    "stock_type": 2,
    "plan_quantity": 10,
    "real_quantity": 8,
    "auto_restore_type": 2,
    "auto_restore_at": "2026-01-28T06:00:00+08:00",
    "updated_at": "2026-01-28T10:00:00+08:00",
    "channel_stocks": [
        {
            "stock_status": 2,
            "stock_type": 2,
            "channel_code": "POS"
        }
    ]
}
```

**技术实现**：
- 使用 `updated_at` 做乐观锁，防止并发覆盖
- 幂等性：检查是否已处理过
- 更新主表并写入变更记录（同一事务）

---

#### 8.2.2 商品中心下发库存变更（sync-to-pos）

**方式1：消息推送**（推荐）
- 商品中心变更 → 写入 outbox → 发送 RocketMQ 消息
- POS 消费消息，更新本地库存

**方式2：接口拉取**（兜底）
- POS 定时拉取最新库存
- 接口：`POST /api/v1/poi/stock/find-to-pos`

**消息体**：
```json
{
    "brandId": "1",
    "poiId": "1",
    "objectType": "item_stock",
    "eventType": "poi.item.stock",
    "data": {
        "object_id": 1,
        "stock_status": 1,
        "stock_type": 2,
        "plan_quantity": 10,
        "real_quantity": 8,
        "auto_restore_type": 2,
        "auto_restore_at": "2026-01-28T06:00:00+08:00",
        "channel_stocks": [...]
    }
}
```

---

### 8.3 技术实现细节

#### 8.3.1 接收POS上报接口

```java
@PostMapping("/api/v1/poi/stock/sync-from-pos")
public ResponseEntity<?> syncFromPos(@RequestBody StockSyncRequest request) {
    // 1. 查询当前库存
    PoiItemStock stock = stockMapper.selectByBrandIdAndPoiIdAndObjectId(
        request.getBrandId(), request.getPoiId(), request.getObjectId());
    
    // 2. 校验 updated_at（乐观锁）
    if (stock != null && !stock.getUpdatedAt().equals(request.getUpdatedAt())) {
        return ResponseEntity.status(409).body("库存已被其他操作修改");
    }
    
    // 3. 更新库存主表
    stockMapper.updateStock(request);
    
    // 4. 写入变更记录（同一事务）
    stockLogMapper.insert(new PoiItemStockLog(...));
    
    return ResponseEntity.ok().build();
}
```

#### 8.3.2 商品中心下发库存变更

```java
@Transactional
public void updateStock(StockUpdateRequest request) {
    // 1. 更新库存主表
    stockMapper.updateStock(request);
    
    // 2. 写入 outbox（同一个事务）
    outboxMapper.insert(new Outbox("STOCK_SYNC_TO_POS", request));
    
    // 3. 定时任务扫描 outbox，发送消息到 RocketMQ
    // POS 消费消息，更新本地库存
}
```

---

## 九、可能被问到的问题

### 8.1 业务相关

**Q1：你们公司的业务模式是什么？**

**回答**：
> "我们是一个**餐饮 SaaS 平台**，为餐饮商家提供 POS、商品管理、订单管理等服务。主要客户是中小型餐饮连锁（1-100 家门店），日订单量 50-80 万单（全平台）。"

---

**Q2：你们的客户规模？**

**回答**：
> "主要客户是中小型餐饮连锁，门店数量 1-100 家。全平台有 1-2 万家门店，日订单量 50-80 万单。"

---

**Q3：为什么需要库存管理？**

**回答**：
> "餐饮商家需要管理商品库存，防止超卖。比如某个菜品只剩 10 份，如果同时有 20 个订单，就会超卖。我们需要保证库存一致性，防止超卖。"

---

### 8.2 技术相关

**Q4：为什么选择 Outbox 模式？**

**回答**：
> "我们对比了多种方案：
> - RocketMQ 事务消息：性能差，复杂度高
> - 直接发 MQ：无法保证原子性
> - Outbox 模式：性能好，代码简单，可靠性高
> 
> 最终选择了 Outbox 模式，参考了 Uber、Netflix 等公司的方案。"

---

**Q5：为什么选择分库分表？**

**回答**：
> "我们的数据量比较大：
> - 全平台 1-2 万家门店
> - 10 万+ SKU
> - 日订单量 50-80 万单
> 
> 单库单表无法支撑，所以选择了分库分表。按 `store_id` 分库，按 `product_id` 分表，使用 ShardingSphere 做分库分表。"

---

**Q6：Redis 预扣减的具体实现？**

**回答**：
> "高并发场景下，我们使用 Redis 预扣减：
> - 使用 Lua 脚本保证原子性
> - 预扣减成功后，写入 outbox
> - 异步同步到数据库
> 
> 这样既保证了性能，又保证了数据一致性。"

---

### 8.3 问题相关

**Q7：locked_stock 为负数是怎么发现的？**

**回答**：
> "我们通过监控发现了这个问题：
> - 监控系统告警：`locked_stock < 0`
> - 查看日志，定位到变成负数的那次操作
> - 发现是重复解锁导致的
> 
> 修复后，我们增加了防御性检查，如果检测到负数会记录错误日志。"

---

**Q8：扫描范围 bug 是怎么发现的？**

**回答**：
> "我们通过监控发现了这个问题：
> - 监控发现部分失败任务一直不重试
> - 检查代码，发现扫描范围不对
> - 修复扫描范围，按实际 shard_id 范围扫描
> 
> 修复后，我们增加了监控，确保所有失败任务都能重试。"

---

**Q9：商品中心与POS同步是怎么实现的？**

**回答**：
> "我们采用了**Outbox 模式 + 消息队列**的方案：
> 
> **接收POS上报**：
> - POS 调用接口上报库存变更
> - 使用 `updated_at` 做乐观锁，防止并发覆盖
> - 幂等性检查，防止重复上报
> 
> **下发至POS**：
> - 商品中心变更时，写入 outbox（本地事务）
> - 定时任务扫描 outbox，发送消息到 RocketMQ
> - POS 消费消息，更新本地库存
> 
> **补偿机制**：
> - 定时任务扫描未同步的变更，补偿失败的消息
> - 对账机制，定期校验数据一致性
> 
> **性能数据**：
> - 消息同步延迟 < 3s（自有渠道），< 10s（三方渠道）
> - 消息丢失率 < 0.01%"

---

**Q10：渠道库存隔离是怎么实现的？**

**回答**：
> "我们采用了**共享库存 + 渠道状态独立**的方案：
> 
> **数据库设计**：
> - `poi_item_stock` 表存储总库存（所有渠道共享）
> - `poi_item_channel_stock` 表存储渠道状态（每个渠道独立）
> 
> **扣减逻辑**：
> - 扣减时检查总库存和渠道库存限制
> - 实际可扣减数量 = min(总库存可用, 渠道限制可用)
> - 使用数据库 WHERE 条件防止超卖
> 
> **并发控制**：
> - 分布式锁 + 数据库行锁 + WHERE 条件，三层防护
> 
> **性能数据**：
> - 超卖率 < 0.01%
> - 并发处理能力 1000+ QPS"

---

## 九、面试回答模板

### 9.1 项目介绍（2分钟）

> "我负责了一个**库存管理系统**，这是整个订单系统的核心模块。
> 
> **业务背景**：
> - 我们是一个餐饮 SaaS 平台，为餐饮商家提供 POS、商品管理、订单管理等服务
> - 主要客户是中小型餐饮连锁（1-100 家门店），全平台有 1-2 万家门店
> - 日订单量 50-80 万单，对性能和一致性要求很高
> 
> **技术架构**：
> - 使用 Outbox 模式保证消息可靠投递
> - 按 store_id 分库，按 product_id 分表，使用 ShardingSphere
> - Redis 预扣减（高并发场景）减少数据库压力
> 
> **核心功能**：
> 1. 库存锁定（下单时）
> 2. 库存扣减（支付后）
> 3. 库存解锁（取消时）
> 4. 防超卖、幂等性保证"

---

### 9.2 技术难点（7分钟）

> "这个项目有5个核心技术难点：
> 
> **1. 分布式一致性**（最高难度）
> - 订单服务和商品服务需要实时同步库存状态
> - 使用 Outbox 模式保证消息可靠投递
> - 遇到了扫描范围 bug，修复后保证所有失败任务都能重试
> - 消息同步延迟 < 3s，消息丢失率 < 0.01%
> 
> **2. 并发控制**（高难度）
> - 支付成功扣减和取消解锁可能并发执行
> - 初始方案只用了乐观锁，导致 locked_stock 为负数
> - 改进为 CAS 更新，从 LOCKED 状态转为 DEDUCTED/UNLOCKED
> - 修复后不再出现负数，数据一致性 99.99%
> 
> **3. 防超卖**（高频面试题）
> - 多端同时扣减库存，如何防止超卖？
> - 数据库 WHERE 条件 + Redis 预扣减 + 分布式锁，三层防护
> - 超卖率 < 0.01%，并发处理能力 1000+ QPS
> 
> **4. 商品中心与POS库存同步**（二期新增，最高难度）
> - 商品中心与POS需要实时同步，目标≤3s
> - 使用 Outbox 模式 + 消息队列 + 补偿机制
> - 消息同步延迟 < 3s，数据一致性 99.99%
> 
> **5. 渠道库存隔离**（二期新增，高难度）
> - 支持按渠道设置库存状态，如何防止超卖？
> - 共享库存 + 渠道状态独立，扣减时检查总库存和渠道限制
> - 超卖率 < 0.01%，并发处理能力 1000+ QPS"

---

### 9.3 线上问题（5分钟）

> "在线上运行过程中，我们遇到了几个问题：
> 
> **问题1：locked_stock 为负数**
> - 通过监控发现，某热门商品 `locked_stock` 出现负数
> - 排查：查看日志，定位到是重复解锁导致的
> - 解决：改为 CAS 更新，修复后不再出现
> - 影响：< 100 单，处理时间 2 小时
> 
> **问题2：扫描范围 bug**
> - 监控发现部分失败任务一直不重试
> - 排查：检查代码，发现扫描范围不对
> - 解决：修复扫描范围，按实际 shard_id 范围扫描
> - 影响：< 1000 个任务，处理时间 1 小时
> 
> **问题3：去重键问题**
> - 商品更新后，缓存不更新
> - 排查：检查 outbox 表，发现后续更新记录没有写入
> - 解决：改为 `(order_id, sku_id)` 唯一索引，用 CAS 更新
> - 影响：< 50 个商品，处理时间 1 小时
> 
> **问题4：商品中心与POS同步延迟**（二期）
> - 商品中心设置库存，但POS延迟收到消息（> 10s）
> - 排查：检查消息队列，发现消息堆积
> - 解决：优化消费者，增加补偿机制
> - 影响：< 100 家门店，处理时间 4 小时
> 
> **问题5：渠道库存超卖**（二期）
> - 某热门商品，POS 和 KIOSK 同时扣减，导致总库存超卖
> - 排查：检查扣减逻辑，发现只检查了渠道限制，没检查总库存
> - 解决：扣减时检查总库存和渠道限制，取最小值
> - 影响：< 50 单，处理时间 2 小时"

---

## 十、总结

### 10.1 核心要点

1. **业务背景要一致**：餐饮 SaaS 平台，1-2 万家门店，50-80 万单/天
2. **技术架构要真实**：Outbox、分库分表、Redis、RocketMQ
3. **技术难点要详细**：
   - 一期：分布式一致性、并发控制、防超卖
   - 二期：商品中心与POS同步、渠道库存隔离
4. **线上问题要真实**：
   - 一期：locked_stock 负数、扫描范围 bug、去重键问题
   - 二期：同步延迟、渠道库存超卖
5. **性能数据要合理**：响应时间、并发能力、数据一致性

### 10.2 避免的坑

- ❌ 不要说"日订单量 1000 万"（不合理）
- ❌ 不要说"我们公司很大"（容易被追问）
- ✅ 说"中小型餐饮连锁"（合理）
- ✅ 说"1-2 万家门店"（合理）
- ✅ 说"50-80 万单/天"（合理）

### 10.3 准备充分

- ✅ 准备业务背景（公司、客户、业务模式）
- ✅ 准备技术架构（技术栈、系统架构）
- ✅ 准备技术难点（3个难点，详细讲解）
- ✅ 准备线上问题（3个问题，详细讲解）
- ✅ 准备性能数据（响应时间、并发能力）
- ✅ 准备可能被问到的问题（业务、技术、问题）
