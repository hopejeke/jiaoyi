# 库存扣减幂等性实现总结（方案2）

## 实现完成

已按照方案2（使用 idempotencyKey）实现了库存扣减的幂等性保证。

## 实现内容

### 1. 创建了幂等性日志表

**表名：** `inventory_deduction_idempotency`

**表结构：**
- `id`：主键ID
- `idempotency_key`：幂等键（唯一约束，格式：orderId + "-DEDUCT"）
- `order_id`：订单ID
- `product_ids`：商品ID列表（JSON格式）
- `sku_ids`：SKU ID列表（JSON格式）
- `quantities`：数量列表（JSON格式）
- `status`：状态（PROCESSING/SUCCESS/FAILED）
- `error_message`：错误信息
- `created_at`：创建时间
- `updated_at`：更新时间

**索引：**
- `UNIQUE KEY (idempotency_key)`：确保幂等键唯一
- `INDEX idx_order_id (order_id)`：订单ID索引
- `INDEX idx_status (status)`：状态索引

### 2. 创建了实体类和 Mapper

**实体类：** `InventoryDeductionIdempotency.java`
- 包含所有字段和状态枚举

**Mapper 接口：** `InventoryDeductionIdempotencyMapper.java`
- `tryInsert()`：尝试插入幂等性日志（INSERT IGNORE）
- `updateStatusToSuccess()`：更新状态为成功
- `updateStatusToFailed()`：更新状态为失败
- `selectByIdempotencyKey()`：根据幂等键查询

**Mapper XML：** `InventoryDeductionIdempotencyMapper.xml`
- 实现了所有 SQL 操作

### 3. 修改了 InventoryService

**新增方法：** `deductStockBatch(List<Long>, List<Long>, List<Integer>, Long, String)`
- 支持传入 `idempotencyKey` 参数
- 实现了完整的幂等性检查逻辑

**保留旧方法：** `deductStockBatch(List<Long>, List<Long>, List<Integer>, Long)`
- 兼容旧接口，自动生成 `idempotencyKey = orderId + "-DEDUCT"`

**幂等性检查流程：**
1. 如果提供了 `idempotencyKey`，先查询是否已存在
2. 如果已存在且状态为 SUCCESS，直接返回（幂等）
3. 如果已存在且状态为 PROCESSING，抛出异常（防止并发）
4. 如果已存在且状态为 FAILED，允许重试
5. 如果不存在，尝试插入幂等性日志（INSERT IGNORE）
6. 执行扣库存操作
7. 成功后更新状态为 SUCCESS
8. 失败后更新状态为 FAILED

### 4. 修改了 InventoryController

**更新了 `DeductStockBatchRequest`：**
- 添加了 `idempotencyKey` 字段（可选）

**更新了 `deductStockBatch` 接口：**
- 传递 `idempotencyKey` 参数到 `InventoryService`

### 5. 更新了 DatabaseInitializer

**添加了 `createInventoryDeductionIdempotencyTable` 方法：**
- 在每个分片库（jiaoyi_product_0/1/2）中创建幂等性日志表
- 在 `createShardingTables` 方法中调用

## 使用方式

### Outbox Handler 中（已实现）

`DeductStockHttpOutboxHandler` 已经传递了 `idempotencyKey`：

```java
String idempotencyKey = command.getIdempotencyKey() != null 
        ? command.getIdempotencyKey() 
        : command.getOrderId() + "-DEDUCT";
request.setIdempotencyKey(idempotencyKey);
```

### 直接调用库存服务

```java
DeductStockBatchRequest request = new DeductStockBatchRequest();
request.setOrderId(orderId);
request.setProductIds(productIds);
request.setSkuIds(skuIds);
request.setQuantities(quantities);
request.setIdempotencyKey(orderId + "-DEDUCT"); // 设置幂等键

inventoryService.deductStockBatch(...);
```

## 幂等性保证

### 场景1：正常流程

```
T1: 第一次调用，idempotencyKey = "123-DEDUCT"
  → 插入幂等性日志（status=PROCESSING）
  → 执行扣库存
  → 更新状态为 SUCCESS

T2: 第二次调用，idempotencyKey = "123-DEDUCT"
  → 查询到已存在，status=SUCCESS
  → 直接返回（幂等）
```

### 场景2：重试场景

```
T1: 第一次调用，idempotencyKey = "123-DEDUCT"
  → 插入幂等性日志（status=PROCESSING）
  → 执行扣库存失败
  → 更新状态为 FAILED

T2: 重试调用，idempotencyKey = "123-DEDUCT"
  → 查询到已存在，status=FAILED
  → 允许重试，继续执行
  → 执行扣库存成功
  → 更新状态为 SUCCESS
```

### 场景3：并发场景

```
T1: 实例A调用，idempotencyKey = "123-DEDUCT"
  → INSERT IGNORE 插入幂等性日志（成功）

T2: 实例B调用，idempotencyKey = "123-DEDUCT"
  → INSERT IGNORE 插入幂等性日志（失败，已存在）
  → 查询状态，如果是 PROCESSING，抛出异常
  → 如果是 SUCCESS，直接返回（幂等）
```

## 数据库表创建

表会在应用启动时自动创建（通过 `DatabaseInitializer`），每个分片库（jiaoyi_product_0/1/2）都会创建一张表。

也可以手动执行 SQL：

```sql
-- 见 product-service/src/main/resources/sql/create_inventory_deduction_idempotency_table.sql
```

## 总结

✅ **已完成：**
1. 创建了幂等性日志表和相关代码
2. 实现了完整的幂等性检查逻辑
3. 支持重试和并发场景
4. 兼容旧接口（自动生成 idempotencyKey）

✅ **保证：**
- 同一个 `idempotencyKey` 的请求只会成功处理一次
- 重试时不会重复扣库存
- 并发时不会重复扣库存


