# 订单表（Orders）分片配置说明

## 一、分片架构概览

### 1.1 物理结构

```
┌─────────────────────────────────────────────────────────────┐
│                   订单表分片架构                              │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  数据库层（3个库）：                                           │
│  ├─ jiaoyi_order_0 (ds0)                                     │
│  │  ├─ orders_00, orders_01, ..., orders_31 (32张表)         │
│  │  ├─ order_items_00, order_items_01, ..., order_items_31  │
│  │  ├─ order_coupons_00, order_coupons_01, ..., order_coupons_31 │
│  │  ├─ payments_00, payments_01, ..., payments_31           │
│  │  ├─ refunds_00, refunds_01, ..., refunds_31              │
│  │  ├─ refund_items_00, refund_items_01, ..., refund_items_31 │
│  │  ├─ deliveries_00, deliveries_01, ..., deliveries_31     │
│  │  ├─ doordash_retry_task_00, ..., doordash_retry_task_31 │
│  │  └─ outbox_00, outbox_01, ..., outbox_31                 │
│  ├─ jiaoyi_order_1 (ds1)                                     │
│  │  └─ （同上，32张表）                                       │
│  └─ jiaoyi_order_2 (ds2)                                     │
│     └─ （同上，32张表）                                       │
│                                                               │
│  总计：3库 × 32表 = 96张物理表（每个表类型）                  │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 分片键

**分片键字段：`store_id`（Long类型）**

- ✅ **使用 `store_id` 作为分片键**（不是 `merchant_id` 或 `shard_id`）
- ✅ 与商品服务保持一致，确保跨服务查询效率
- ✅ 与 outbox 表保持一致，确保同库事务

### 1.3 绑定表（Binding Tables）

**订单域绑定表组**：`order_binding`

包含以下表（使用相同的分片键和分片算法）：
- `orders`（订单主表）
- `order_items`（订单项表）
- `order_coupons`（订单优惠券表）
- `payments`（支付记录表）
- `refunds`（退款单表）
- `refund_items`（退款明细表）
- `deliveries`（配送表）
- `doordash_retry_task`（DoorDash重试任务表）

**绑定表的好处**：
- ✅ **同库事务**：所有相关表在同一数据库，支持本地事务
- ✅ **JOIN 优化**：ShardingSphere 可以优化 JOIN 查询，避免跨库
- ✅ **数据一致性**：订单和订单项、支付记录等在同一分片

---

## 二、分片算法

### 2.1 数据库分片算法（`StoreIdDatabaseShardingAlgorithm`）

**配置位置**：`order-service/src/main/java/com/jiaoyi/order/config/ShardingSphereConfig.java`

```java
// 分库策略配置
tableRule.setDatabaseShardingStrategy(
    new StandardShardingStrategyConfiguration("store_id", "store_id_database")
);
```

**算法逻辑**：

```java
// 第一步：计算 shard_id（固定1024个虚拟桶）
int shardId = hash(store_id) & 1023;  // 结果：0-1023
// 使用 Murmur3 哈希算法，保证分布均匀

// 第二步：计算数据库索引
int dsIndex = shardId % 3;  // 结果：0/1/2

// 第三步：路由到对应数据库
String dsName = "ds" + dsIndex;  // 结果：ds0/ds1/ds2
```

**哈希算法**：`Murmur3_32`（Guava 实现）

```java
// ShardUtil.calculateShardId(storeId)
int hashCode = Hashing.murmur3_32()
    .hashString(String.valueOf(storeId), StandardCharsets.UTF_8)
    .asInt();
int shardId = hashCode & 1023;  // 位运算取模，性能更好
```

**示例**：

| store_id | hash(store_id) | shard_id (hash & 1023) | dsIndex (shard_id % 3) | 路由到数据库 |
|----------|----------------|------------------------|------------------------|--------------|
| 1001     | 123456789      | 789                    | 0                      | ds0          |
| 1002     | 987654321      | 321                    | 0                      | ds0          |
| 1003     | 456789123      | 123                    | 0                      | ds0          |
| 2001     | 111222333      | 333                    | 0                      | ds0          |
| 2002     | 222333444      | 444                    | 0                      | ds0          |
| 3001     | 333444555      | 555                    | 0                      | ds0          |

### 2.2 表分片算法（`StoreIdTableShardingAlgorithm`）

**配置位置**：`order-service/src/main/java/com/jiaoyi/order/config/ShardingSphereConfig.java`

```java
// 分表策略配置
tableRule.setTableShardingStrategy(
    new StandardShardingStrategyConfiguration("store_id", "store_id_table")
);
```

**算法逻辑**：

```java
// 第一步：计算 shard_id（固定1024个虚拟桶）
int shardId = hash(store_id) & 1023;  // 结果：0-1023

// 第二步：计算表索引
int tableIndex = shardId % 32;  // 结果：0-31

// 第三步：生成表名
String tableName = "orders_" + String.format("%02d", tableIndex);
// 结果：orders_00, orders_01, ..., orders_31
```

**示例**：

| store_id | shard_id | tableIndex (shard_id % 32) | 路由到表 |
|----------|----------|----------------------------|----------|
| 1001     | 789      | 21                         | orders_21 |
| 1002     | 321      | 1                          | orders_01 |
| 1003     | 123      | 27                         | orders_27 |
| 2001     | 333      | 13                         | orders_13 |
| 2002     | 444      | 28                         | orders_28 |
| 3001     | 555      | 11                         | orders_11 |

---

## 三、完整路由示例

### 3.1 创建订单

**业务代码**：`order-service/src/main/java/com/jiaoyi/order/service/OrderService.java`

```java
@Transactional
public Order createOrder(Order order, List<OrderItem> orderItems) {
    // 1. 从订单项中获取 storeId
    Long storeId = orderItems.get(0).getStoreId();  // 例如：storeId = 1001
    
    // 2. 设置 storeId 到订单和订单项
    order.setStoreId(storeId);
    for (OrderItem item : orderItems) {
        item.setStoreId(storeId);
    }
    
    // 3. 计算 shard_id（用于业务逻辑，ShardingSphere 会自动路由）
    int shardId = ShardUtil.calculateShardId(storeId);  // 例如：shardId = 789
    order.setShardId(shardId);
    for (OrderItem item : orderItems) {
        item.setShardId(shardId);
    }
    
    // 4. 插入订单（ShardingSphere 自动路由）
    orderMapper.insert(order);
    // ShardingSphere 路由：store_id=1001 → ds0.orders_21
    
    // 5. 插入订单项（ShardingSphere 自动路由）
    orderItemMapper.insertBatch(orderItems);
    // ShardingSphere 路由：store_id=1001 → ds0.order_items_21
    
    // ✅ 所有操作在同一数据库（ds0），支持本地事务
    return order;
}
```

**ShardingSphere 路由过程**：

```
1. 接收到 INSERT INTO orders (store_id, ...) VALUES (1001, ...)
   ↓
2. 提取分片键：store_id = 1001
   ↓
3. 数据库分片算法：
   - shard_id = hash(1001) & 1023 = 789
   - dsIndex = 789 % 3 = 0
   - 路由到：ds0 (jiaoyi_order_0)
   ↓
4. 表分片算法：
   - tableIndex = 789 % 32 = 21
   - 路由到：orders_21
   ↓
5. 最终SQL：
   INSERT INTO jiaoyi_order_0.orders_21 (store_id, ...) VALUES (1001, ...)
```

### 3.2 查询订单

**场景1：精确查询（带 store_id）**

```sql
-- 业务SQL（逻辑表）
SELECT * FROM orders WHERE store_id = 1001 AND id = 123456;

-- ShardingSphere 路由后（物理表）
SELECT * FROM jiaoyi_order_0.orders_21 WHERE store_id = 1001 AND id = 123456;
```

**场景2：JOIN 查询（绑定表优化）**

```sql
-- 业务SQL（逻辑表）
SELECT o.*, oi.* 
FROM orders o 
JOIN order_items oi ON o.id = oi.order_id 
WHERE o.store_id = 1001 AND o.id = 123456;

-- ShardingSphere 路由后（物理表，同库JOIN）
SELECT o.*, oi.* 
FROM jiaoyi_order_0.orders_21 o 
JOIN jiaoyi_order_0.order_items_21 oi ON o.id = oi.order_id 
WHERE o.store_id = 1001 AND o.id = 123456;

-- ✅ 绑定表优化：ShardingSphere 知道 orders 和 order_items 在同一分片
-- ✅ 无需跨库查询，性能最优
```

**场景3：范围查询（不带 store_id）**

```sql
-- 业务SQL（逻辑表）
SELECT * FROM orders WHERE status = 1 AND create_time > '2024-01-01';

-- ShardingSphere 路由后（广播到所有表）
SELECT * FROM jiaoyi_order_0.orders_00 WHERE status = 1 AND create_time > '2024-01-01';
SELECT * FROM jiaoyi_order_0.orders_01 WHERE status = 1 AND create_time > '2024-01-01';
...
SELECT * FROM jiaoyi_order_2.orders_31 WHERE status = 1 AND create_time > '2024-01-01';
-- 共96条SQL（3库 × 32表），然后合并结果
```

---

## 四、关键字段说明

### 4.1 Order 实体字段

**位置**：`order-service/src/main/java/com/jiaoyi/order/entity/Order.java`

```java
public class Order {
    /**
     * 门店ID（用于分片，与商品服务保持一致）
     * 注意：ShardingSphere 使用 store_id 作为分片键进行数据库和表路由
     */
    private Long storeId;  // 例如：1001L
    
    /**
     * 分片ID（0-1023，基于 storeId 计算，用于分库分表路由）
     * 注意：此字段必须与 storeId 一起设置，确保分片一致性
     * 注意：ShardingSphere 不使用此字段路由，但业务代码可以使用此字段进行优化
     */
    private Integer shardId;  // 例如：789（0-1023）
}
```

### 4.2 字段关系

```
storeId (Long) ──> ShardingSphere 分片路由
    │
    └──> 计算 shardId (Integer) ──> 业务逻辑优化（可选）
```

**注意**：
- ✅ **`store_id`**：ShardingSphere 的分片键，**必须提供**
- ⚠️ **`shard_id`**：业务字段，用于扫描优化，**可选**（ShardingSphere 不使用此字段路由）

---

## 五、分片配置代码

### 5.1 ShardingSphere 配置

**位置**：`order-service/src/main/java/com/jiaoyi/order/config/ShardingSphereConfig.java`

```java
private ShardingTableRuleConfiguration createOrdersTableRule() {
    // 实际数据节点：ds0/1/2 每个库都有 32 张表（orders_00..orders_31）
    String actualDataNodes = buildActualDataNodes("orders", 3, 32);
    // 结果：ds0.orders_00,ds0.orders_01,...,ds2.orders_31
    
    ShardingTableRuleConfiguration tableRule = 
        new ShardingTableRuleConfiguration("orders", actualDataNodes);
    
    // 使用 store_id 作为分片键（数据库路由）
    tableRule.setDatabaseShardingStrategy(
        new StandardShardingStrategyConfiguration("store_id", "store_id_database")
    );
    
    // 使用 store_id 作为分片键（表路由）
    tableRule.setTableShardingStrategy(
        new StandardShardingStrategyConfiguration("store_id", "store_id_table")
    );
    
    // 主键生成策略（雪花算法）
    tableRule.setKeyGenerateStrategy(
        new KeyGenerateStrategyConfiguration("id", "snowflake")
    );
    
    return tableRule;
}
```

### 5.2 绑定表配置

```java
// 创建绑定表组
ShardingTableReferenceRuleConfiguration bindingTableRule = 
    new ShardingTableReferenceRuleConfiguration("order_binding", 
        "orders,order_items,order_coupons,payments,refunds,refund_items,deliveries,doordash_retry_task");
shardingRuleConfig.getBindingTableGroups().add(bindingTableRule);
```

**绑定表的好处**：
- ✅ **JOIN 优化**：ShardingSphere 知道这些表在同一分片，可以优化 JOIN
- ✅ **同库事务**：所有表在同一数据库，支持本地事务
- ✅ **查询效率**：避免跨库查询

### 5.3 分片算法配置

**数据库分片算法**：`StoreIdDatabaseShardingAlgorithm`

```java
Properties dbShardingProps = new Properties();
dbShardingProps.setProperty("strategy", "STANDARD");
dbShardingProps.setProperty("algorithmClassName", 
    "com.jiaoyi.order.config.StoreIdDatabaseShardingAlgorithm");
dbShardingProps.setProperty("ds-count", "3");      // 数据源数量：ds0, ds1, ds2
dbShardingProps.setProperty("ds-prefix", "ds");   // 数据源名称前缀

shardingRuleConfig.getShardingAlgorithms().put("store_id_database",
    new AlgorithmConfiguration("CLASS_BASED", dbShardingProps));
```

**表分片算法**：`StoreIdTableShardingAlgorithm`

```java
Properties tableShardingProps = new Properties();
tableShardingProps.setProperty("strategy", "STANDARD");
tableShardingProps.setProperty("algorithmClassName", 
    "com.jiaoyi.order.config.StoreIdTableShardingAlgorithm");
tableShardingProps.setProperty("table.count.per.db", "32");  // 每库32张表

shardingRuleConfig.getShardingAlgorithms().put("store_id_table",
    new AlgorithmConfiguration("CLASS_BASED", tableShardingProps));
```

---

## 六、分片一致性保证

### 6.1 与订单项表保持一致

**关键点**：订单项表使用与订单表相同的分片键（`store_id`），确保：

1. ✅ **同库事务**：订单和订单项在同一数据库，支持本地事务
2. ✅ **JOIN 优化**：ShardingSphere 可以优化 JOIN 查询
3. ✅ **数据一致性**：订单创建和订单项插入在同一事务中完成

**示例**：

```java
@Transactional
public void createOrder(Order order, List<OrderItem> orderItems) {
    // 1. 插入订单（路由到 jiaoyi_order_0.orders_21）
    orderMapper.insert(order);
    
    // 2. 插入订单项（路由到 jiaoyi_order_0.order_items_21）
    orderItemMapper.insertBatch(orderItems);
    
    // ✅ 所有操作在同一数据库（ds0），支持本地事务
    // ✅ ShardingSphere 知道 orders 和 order_items 在同一分片
}
```

### 6.2 与支付表保持一致

**关键点**：支付表使用与订单表相同的分片键（`store_id`），确保：

1. ✅ **同库事务**：订单和支付记录在同一数据库，支持本地事务
2. ✅ **查询效率**：查询订单的支付记录时，无需跨库

**示例**：

```java
@Transactional
public void createOrderWithPayment(Order order, PaymentRequest paymentRequest) {
    // 1. 插入订单（路由到 jiaoyi_order_0.orders_21）
    orderMapper.insert(order);
    
    // 2. 创建支付记录（路由到 jiaoyi_order_0.payments_21）
    Payment payment = createPaymentRecord(order, paymentRequest);
    paymentMapper.insert(payment);
    
    // ✅ 所有操作在同一数据库（ds0），支持本地事务
}
```

### 6.3 与商品服务保持一致

**关键点**：订单表使用与商品服务相同的分片键（`store_id`），确保：

1. ✅ **跨服务查询效率**：查询商品相关的订单时，无需跨库
2. ✅ **数据一致性**：订单和商品在同一分片

---

## 七、主键生成策略

### 7.1 雪花算法（Snowflake）

**配置**：

```java
tableRule.setKeyGenerateStrategy(
    new KeyGenerateStrategyConfiguration("id", "snowflake")
);
```

**特点**：
- ✅ **分布式唯一**：保证全局唯一ID
- ✅ **趋势递增**：ID 按时间递增，有利于索引
- ✅ **高性能**：无需数据库自增，性能更好

**ID 格式**：
```
64位 = 1位符号位 + 41位时间戳 + 10位机器ID + 12位序列号
```

**示例**：
```
1234567890123456789  (19位数字)
```

---

## 八、查询优化建议

### 8.1 必须带分片键

**✅ 推荐**：

```sql
-- 带 store_id（精确路由）
SELECT * FROM orders WHERE store_id = 1001 AND id = 123456;
-- 路由到：ds0.orders_21（单表查询）

-- 带 store_id（范围查询）
SELECT * FROM orders WHERE store_id = 1001 AND create_time > '2024-01-01';
-- 路由到：ds0.orders_21（单表查询）
```

**❌ 不推荐**：

```sql
-- 不带 store_id（广播查询）
SELECT * FROM orders WHERE id = 123456;
-- 路由到：所有96张表（性能差）

-- 不带 store_id（范围查询）
SELECT * FROM orders WHERE create_time > '2024-01-01';
-- 路由到：所有96张表（性能差）
```

### 8.2 使用绑定表优化 JOIN

**✅ 推荐**：

```sql
-- JOIN 绑定表（ShardingSphere 优化）
SELECT o.*, oi.* 
FROM orders o 
JOIN order_items oi ON o.id = oi.order_id 
WHERE o.store_id = 1001;
-- 路由到：ds0.orders_21 JOIN ds0.order_items_21（同库JOIN）
```

**❌ 不推荐**：

```sql
-- JOIN 非绑定表（可能跨库）
SELECT o.*, p.* 
FROM orders o 
JOIN payments p ON o.id = p.order_id 
WHERE o.store_id = 1001;
-- 注意：如果 payments 表不在绑定表中，可能跨库JOIN
```

### 8.3 避免全表扫描

**❌ 避免**：

```sql
-- 全表扫描（广播到所有表）
SELECT COUNT(*) FROM orders;
-- 路由到：所有96张表，然后合并结果（性能差）

-- 全表扫描（广播到所有表）
SELECT * FROM orders ORDER BY create_time DESC LIMIT 10;
-- 路由到：所有96张表，然后排序合并（性能差）
```

**✅ 推荐**：

```sql
-- 带分片键（单表查询）
SELECT COUNT(*) FROM orders WHERE store_id = 1001;
-- 路由到：ds0.orders_21（单表查询）

-- 带分片键（单表查询）
SELECT * FROM orders 
WHERE store_id = 1001 
ORDER BY create_time DESC 
LIMIT 10;
-- 路由到：ds0.orders_21（单表查询）
```

---

## 九、总结

### 9.1 分片配置

| 维度 | 配置值 |
|------|--------|
| **分片键** | `store_id` (Long) |
| **数据库数量** | 3个（ds0, ds1, ds2） |
| **每库表数量** | 32张（orders_00..orders_31） |
| **总表数量** | 96张（3库 × 32表） |
| **数据库分片算法** | `store_id % 3`（通过 shard_id 计算） |
| **表分片算法** | `store_id % 32`（通过 shard_id 计算） |
| **虚拟桶数量** | 1024个（shard_id: 0-1023） |
| **哈希算法** | Murmur3_32 |
| **主键生成** | 雪花算法（Snowflake） |
| **绑定表** | orders, order_items, order_coupons, payments, refunds, refund_items, deliveries, doordash_retry_task |

### 9.2 关键特性

✅ **与商品服务一致**：使用相同的分片键（`store_id`），保证跨服务查询效率  
✅ **绑定表优化**：订单域所有表在同一分片，支持同库事务和 JOIN 优化  
✅ **可扩展性**：固定1024个虚拟桶，支持未来扩容  
✅ **高性能**：使用 Murmur3 哈希算法，保证分布均匀  

### 9.3 注意事项

⚠️ **分片键必填**：插入订单时必须提供 `store_id`，否则会报错  
⚠️ **查询性能**：不带 `store_id` 的查询会广播到所有96张表，需要合理使用  
⚠️ **绑定表**：使用绑定表可以优化 JOIN 查询，避免跨库  

---

## 十、相关文件

- **ShardingSphere 配置**：`order-service/src/main/java/com/jiaoyi/order/config/ShardingSphereConfig.java`
- **数据库分片算法**：`order-service/src/main/java/com/jiaoyi/order/config/StoreIdDatabaseShardingAlgorithm.java`
- **表分片算法**：`order-service/src/main/java/com/jiaoyi/order/config/StoreIdTableShardingAlgorithm.java`
- **分片工具类**：`order-service/src/main/java/com/jiaoyi/order/util/ShardUtil.java`
- **Order 实体**：`order-service/src/main/java/com/jiaoyi/order/entity/Order.java`
- **OrderService**：`order-service/src/main/java/com/jiaoyi/order/service/OrderService.java`



