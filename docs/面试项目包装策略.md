# 面试项目包装策略

## 一、核心建议

**以实际项目为主，设计文档为辅**

### 1.1 为什么选择实际项目？

| 维度 | 实际项目（jiaoyi） | 设计文档 | 胜者 |
|-----|----------------|---------|------|
| **真实性** | ✅ 真实代码，可演示 | ❌ 只有文档 | ✅ 实际项目 |
| **深度** | ✅ 能讲出实现细节 | ❌ 只有设计思路 | ✅ 实际项目 |
| **问题解决** | ✅ 能讲出实际遇到的问题 | ❌ 只有理论 | ✅ 实际项目 |
| **技术栈** | ✅ 有outbox、分库分表等 | ❌ 不明确 | ✅ 实际项目 |
| **说服力** | ✅ 有代码可讲 | ❌ 只有设计 | ✅ 实际项目 |

**结论**：面试官更看重**实际项目经验**，有代码可讲更有说服力。

---

## 二、包装策略

### 2.1 主线：实际项目（80%）

**核心故事**：
> "我负责了一个**库存管理系统**，支持多端（订单服务、商品服务）的库存扣减、锁定、解锁。日订单量 50-80 万，对性能和一致性要求很高。"

**技术亮点**：
1. **分布式一致性**：使用 Outbox 模式保证消息可靠投递
2. **并发控制**：CAS 更新 + 分布式锁 + 数据库行锁，三层防护
3. **防超卖**：数据库 WHERE 条件 + Redis 预扣减（可选）
4. **分库分表**：按 store_id 分库，支持水平扩展
5. **幂等性**：唯一索引 + 流水表，保证幂等

**实际遇到的问题**：
1. **并发漏洞**：deduct 和 unlock 并发执行，导致 locked_stock 为负数
   - 问题：只用了乐观锁，高并发场景下不够
   - 解决：改为 CAS 更新，从 LOCKED 状态转为 DEDUCTED/UNLOCKED
   
2. **扫描范围 bug**：OutboxCleanupTask 只扫描 0-9，但实际 shard_id 是 0-1023
   - 问题：大部分失败任务永远不会被重试
   - 解决：修复扫描范围，按实际 shard_id 扫描

3. **去重键问题**：商品服务 CREATE/UPDATE/DELETE 都用同一个 type，导致后续更新丢失
   - 问题：唯一索引 (type, biz_key) 导致后续操作失败
   - 解决：改为 (order_id, sku_id) 唯一索引，用 CAS 更新做状态机

---

### 2.2 辅线：设计文档（20%）

**作为"优化方案"或"新需求"来讲**：

> "最近我们接到了一个新需求，要支持**商品中心和 POS 的库存同步**，需要实现：
> 
> 1. **多端实时同步**：商品中心和 POS 需要实时同步库存状态，目标≤3s
> 2. **渠道维度库存**：支持按渠道（POS、KIOSK、ONLINE_ORDER）设置库存
> 3. **自动恢复库存**：支持次日自动恢复、指定时间恢复
> 
> 我负责技术方案设计，主要解决了：
> 
> **1. 分布式一致性**
> - 使用 Outbox 模式保证消息可靠投递
> - 消息队列（RocketMQ）做同步
> - 补偿机制处理失败消息
> 
> **2. 并发控制**
> - 设计文档只用了乐观锁（`updated_at`），我建议增加分布式锁
> - 数据库行锁 + 版本号机制，三层防护
> 
> **3. 渠道库存隔离**
> - 共享库存 + 渠道状态独立
> - 扣减时检查渠道状态，防止超卖"

---

## 三、具体包装方案

### 3.1 项目介绍（2分钟）

> "我负责了一个**库存管理系统**，这是整个订单系统的核心模块。
> 
> **业务背景**：
> - 支持多端（订单服务、商品服务）的库存扣减、锁定、解锁
> - 日订单量 50-80 万，对性能和一致性要求很高
> 
> **技术架构**：
> - 使用 Outbox 模式保证消息可靠投递
> - 按 store_id 分库，支持水平扩展
> - Redis 预扣减（可选）减少数据库压力
> 
> **核心功能**：
> 1. 库存锁定（下单时）
> 2. 库存扣减（支付后）
> 3. 库存解锁（取消时）
> 4. 防超卖、幂等性保证"

---

### 3.2 技术难点（5分钟）

#### 难点1：分布式一致性（重点讲）

> "最大的技术难点是**分布式一致性**。
> 
> **问题**：
> - 订单服务和商品服务需要实时同步库存状态
> - 使用 Outbox 模式保证消息可靠投递
> 
> **实现**：
> - 库存扣减时，先写入 outbox 表（本地事务）
> - 定时任务扫描 outbox，发送消息到商品服务
> - 商品服务消费消息，更新库存
> 
> **遇到的问题**：
> - OutboxCleanupTask 只扫描 shard_id 0-9，但实际是 0-1023
> - 导致大部分失败任务永远不会被重试
> - 修复：按实际 shard_id 范围扫描"

#### 难点2：并发控制（重点讲）

> "第二个难点是**并发控制**。
> 
> **问题**：
> - 支付成功扣减（deduct）和取消解锁（unlock）可能并发执行
> - 如何防止已解锁的库存又被扣减？
> 
> **初始方案**：
> - 只用了乐观锁（`updated_at`）
> - 高并发场景下不够，导致 locked_stock 为负数
> 
> **改进方案**：
> - 改为 CAS 更新：从 LOCKED 状态转为 DEDUCTED/UNLOCKED
> - 唯一索引改为 `(order_id, sku_id)`，只允许一条记录
> - 使用状态机，保证只有一个操作能成功
> 
> **代码实现**：
> ```java
> // CAS 更新：从 LOCKED 转为 DEDUCTED
> UPDATE inventory_transactions 
> SET transaction_type = 'OUT'
> WHERE order_id = ? AND sku_id = ? AND transaction_type = 'LOCK'
> ```"

#### 难点3：防超卖（重点讲）

> "第三个难点是**防超卖**。
> 
> **问题**：
> - 多端同时扣减库存，如何防止超卖？
> 
> **方案**：
> - 数据库 WHERE 条件：`WHERE locked_stock >= quantity`
> - Redis 预扣减（高并发场景）：Lua 脚本保证原子性
> - 分布式锁：扣减前先获取锁
> 
> **三层防护**：
> 1. Redis 预扣减（快速响应）
> 2. 数据库行锁（保证原子性）
> 3. WHERE 条件（防止超卖）"

---

### 3.3 新需求/优化方案（2分钟）

> "最近我们接到了一个新需求，要支持**商品中心和 POS 的库存同步**。
> 
> **需求背景**：
> - 商品中心和 POS 需要实时同步库存状态，目标≤3s
> - 支持按渠道（POS、KIOSK、ONLINE_ORDER）设置库存
> 
> **技术方案**：
> - 使用 Outbox 模式保证消息可靠投递
> - 消息队列（RocketMQ）做同步
> - 补偿机制处理失败消息
> 
> **设计改进**：
> - 原设计只用了乐观锁（`updated_at`），我建议增加分布式锁
> - 增加补偿机制、对账机制，保证最终一致性"

---

## 四、面试回答模板

### 4.1 项目介绍（精简版）

> "我负责了一个**库存管理系统**，支持多端的库存扣减、锁定、解锁。
> 
> **技术亮点**：
> 1. **分布式一致性**：使用 Outbox 模式保证消息可靠投递
> 2. **并发控制**：CAS 更新 + 分布式锁 + 数据库行锁，三层防护
> 3. **防超卖**：数据库 WHERE 条件 + Redis 预扣减
> 4. **分库分表**：按 store_id 分库，支持水平扩展
> 
> **解决的问题**：
> - 修复了并发漏洞（locked_stock 为负数）
> - 修复了扫描范围 bug（失败任务永不重试）
> - 优化了去重键设计（CAS 更新做状态机）"

---

### 4.2 技术难点（详细版）

> "这个项目有3个核心技术难点：
> 
> **1. 分布式一致性**（最高难度）
> - 使用 Outbox 模式保证消息可靠投递
> - 遇到了扫描范围 bug，修复后保证所有失败任务都能重试
> 
> **2. 并发控制**（高难度）
> - 初始方案只用了乐观锁，导致 locked_stock 为负数
> - 改进为 CAS 更新，从 LOCKED 状态转为 DEDUCTED/UNLOCKED
> - 唯一索引改为 `(order_id, sku_id)`，用状态机保证互斥
> 
> **3. 防超卖**（高频面试题）
> - 数据库 WHERE 条件：`WHERE locked_stock >= quantity`
> - Redis 预扣减（Lua 脚本）减少数据库压力
> - 分布式锁保证原子性"

---

### 4.3 新需求/优化方案（加分项）

> "最近我们接到了一个新需求，要支持**商品中心和 POS 的库存同步**。
> 
> **需求**：
> - 多端实时同步，目标≤3s
> - 支持渠道维度库存
> 
> **技术方案**：
> - 使用 Outbox 模式 + 消息队列
> - 增加分布式锁、补偿机制、对账机制
> 
> **设计改进**：
> - 原设计只用了乐观锁，我建议增加分布式锁
> - 增加补偿机制，保证最终一致性"

---

## 五、面试技巧

### 5.1 如何组织回答

1. **先说实际项目**（80%）
   - 项目背景、技术架构
   - 核心技术难点（3个）
   - 实际遇到的问题和解决方案

2. **再说设计文档**（20%）
   - 作为"新需求"或"优化方案"
   - 说明如何设计技术方案
   - 指出原设计的问题，提出改进建议

3. **最后总结**
   - 技术栈：Outbox、分库分表、Redis、消息队列
   - 核心能力：分布式一致性、并发控制、防超卖

---

### 5.2 避免的坑

- ❌ 不要说"我只做了设计，没写代码"
- ❌ 不要说"这个项目不是我做的"
- ✅ 强调"我负责了核心模块的开发"
- ✅ 强调"遇到了实际问题，并解决了"

---

### 5.3 加分项

- 提到实际遇到的问题（locked_stock 负数、扫描范围 bug）
- 提到如何修复（CAS 更新、修复扫描范围）
- 提到性能数据（日订单量 50-80 万）
- 提到技术选型理由（为什么用 Outbox、为什么分库）

---

## 六、总结

### 6.1 核心策略

**以实际项目为主（80%），设计文档为辅（20%）**

- ✅ 实际项目有代码可讲，更有说服力
- ✅ 设计文档作为"新需求"，体现架构设计能力
- ✅ 两者结合，既有深度又有广度

### 6.2 回答结构

```
1. 项目介绍（2分钟）
   - 业务背景、技术架构
   
2. 技术难点（5分钟）
   - 分布式一致性（重点）
   - 并发控制（重点）
   - 防超卖（重点）
   
3. 新需求/优化方案（2分钟）
   - 商品中心和 POS 同步
   - 设计改进建议
   
4. 总结（1分钟）
   - 技术栈、核心能力
```

### 6.3 面试价值

| 内容 | 面试价值 | 建议 |
|-----|---------|------|
| **实际项目** | ⭐⭐⭐⭐⭐ | 重点讲，80%时间 |
| **设计文档** | ⭐⭐⭐⭐ | 辅助讲，20%时间 |
| **两者结合** | ⭐⭐⭐⭐⭐ | 最佳策略 |
