# 虚拟桶方案实施分析

## 当前项目状态

### ✅ 已实现的部分

1. **虚拟桶计算**
   - `ProductShardUtil.calculateProductShardId()` 已实现
   - 使用 MurmurHash3，1024 个虚拟桶
   - 与方案一致 ✅

2. **路由表结构**
   - `product_shard_bucket_route` 表已存在
   - 字段：`bucket_id`, `ds_name`, `status`, `updated_at`
   - **差异**：缺少 `tbl_id`（表路由）字段 ❌

3. **路由缓存**
   - `ProductRouteCache` 已实现
   - 支持全量加载、增量刷新、强制刷新
   - 支持版本号（基于 `updated_at`）
   - **差异**：缺少表路由缓存 ❌

### ❌ 未实现的部分

1. **ShardingSphere 分片算法未使用路由表**
   - 当前使用纯函数：`product_shard_id % 3`（库路由）
   - 当前使用纯函数：`product_shard_id % 32`（表路由）
   - **问题**：无法动态调整路由，扩容需要全量迁移 ❌

2. **路由表缺少表路由字段**
   - 当前只有 `ds_name`，没有 `tbl_id`
   - **问题**：无法支持表级别的动态路由 ❌

3. **缺少迁移状态支持**
   - 路由表有 `status` 字段，但分片算法未使用
   - **问题**：无法支持迁移中的双写 ❌

4. **缺少 bucket_id 字段**
   - 业务表没有 `bucket_id` 字段
   - **问题**：迁移时无法按 bucket 筛选数据 ❌

---

## 方案对比

| 功能 | 当前实现 | 方案要求 | 状态 |
|------|---------|---------|------|
| 虚拟桶计算（1024） | ✅ 已实现 | ✅ 需要 | ✅ 一致 |
| 路由表（库路由） | ✅ 已存在 | ✅ 需要 | ✅ 一致 |
| 路由表（表路由） | ❌ 缺少 | ✅ 需要 | ❌ 需添加 |
| 路由缓存 | ✅ 已实现 | ✅ 需要 | ✅ 一致 |
| ShardingSphere 使用路由表 | ❌ 未使用 | ✅ 需要 | ❌ 需改造 |
| 迁移状态支持 | ❌ 未实现 | ✅ 需要 | ❌ 需实现 |
| 双写支持 | ❌ 未实现 | ✅ 需要 | ❌ 需实现 |
| bucket_id 字段 | ❌ 未添加 | ✅ 需要 | ❌ 需添加 |
| 版本号热更新 | ✅ 已实现 | ✅ 需要 | ✅ 一致 |

---

## 实施建议

### 阶段一：完善路由表结构（1-2天）

#### 1.1 扩展路由表，添加表路由字段

```sql
-- 扩展 product_shard_bucket_route 表
ALTER TABLE product_shard_bucket_route 
ADD COLUMN tbl_id INT NOT NULL DEFAULT 0 COMMENT '表后缀（0-31）' AFTER ds_name,
ADD COLUMN version BIGINT NOT NULL DEFAULT 1 COMMENT '映射版本号，用于缓存更新' AFTER status,
ADD COLUMN target_ds_id VARCHAR(32) NULL COMMENT '迁移目标数据源（仅 MIGRATING 状态有值）' AFTER version,
ADD COLUMN target_tbl_id INT NULL COMMENT '迁移目标表（仅 MIGRATING 状态有值）' AFTER target_ds_id;

-- 初始化表路由（当前使用 product_shard_id % 32）
UPDATE product_shard_bucket_route 
SET tbl_id = bucket_id % 32;

-- 添加索引
CREATE INDEX idx_tbl_id ON product_shard_bucket_route(tbl_id);
CREATE INDEX idx_version ON product_shard_bucket_route(version);
```

#### 1.2 更新路由表结构（与方案对齐）

```sql
-- 重命名表（可选，保持一致性）
-- RENAME TABLE product_shard_bucket_route TO shard_bucket_map;

-- 或者保持表名，但字段对齐
-- 当前表名：product_shard_bucket_route
-- 方案表名：shard_bucket_map
-- 建议：保持当前表名，但字段对齐方案
```

### 阶段二：改造 ShardingSphere 分片算法（3-5天）

#### 2.1 改造数据库路由算法

**当前实现**（`ProductShardIdDatabaseShardingAlgorithm.java`）：
```java
// 纯函数计算
int dsIndex = Math.floorMod(productShardId, dsCount);
String dsName = dsPrefix + dsIndex;
```

**需要改造为**（参考方案）：
```java
// 从路由缓存查询
BucketMapping mapping = mappingCache.getMapping(productShardId);
String dsName = mapping.getDsId();
```

#### 2.2 改造表路由算法

**当前实现**（`ProductShardIdTableShardingAlgorithm.java`）：
```java
// 纯函数计算
int tableIndex = productShardId % tableCountPerDb;
String tableSuffix = String.format("%02d", tableIndex);
```

**需要改造为**（参考方案）：
```java
// 从路由缓存查询
BucketMapping mapping = mappingCache.getMapping(productShardId);
String tableSuffix = String.format("%02d", mapping.getTblId());
```

#### 2.3 扩展 ProductRouteCache

需要添加表路由缓存：

```java
// 当前只有库路由
private final Map<Integer, String> routeMap = new ConcurrentHashMap<>(1024);

// 需要添加表路由
private final Map<Integer, Integer> tableRouteMap = new ConcurrentHashMap<>(1024);
```

### 阶段三：添加 bucket_id 字段（2-3天）

#### 3.1 为业务表添加 bucket_id 字段

```sql
-- orders 表
ALTER TABLE orders ADD COLUMN bucket_id INT NOT NULL COMMENT '虚拟桶ID' AFTER store_id;
CREATE INDEX idx_bucket_id ON orders(bucket_id);

-- outbox 表
ALTER TABLE outbox ADD COLUMN bucket_id INT NOT NULL COMMENT '虚拟桶ID' AFTER store_id;
CREATE INDEX idx_bucket_id ON outbox(bucket_id);

-- 其他业务表...
```

#### 3.2 实现自动填充拦截器

参考方案中的 `BucketIdAutoFillInterceptor`，在 INSERT 时自动填充 `bucket_id`。

### 阶段四：实现迁移支持（5-7天）

#### 4.1 迁移状态管理

- 支持 `MIGRATING` 状态
- 支持 `target_ds_id` 和 `target_tbl_id`
- 支持双写逻辑

#### 4.2 迁移工具

- 数据迁移脚本（按 bucket 筛选）
- 迁移计划管理
- 迁移状态切换

---

## 关键差异点

### 1. 表路由 vs 库路由

**当前实现**：
- 只有库路由（`ds_name`）
- 表路由使用纯函数：`product_shard_id % 32`

**方案要求**：
- 库路由 + 表路由都通过映射表
- 支持表级别的动态调整

**影响**：
- 当前扩容时，表路由无法调整（固定 `% 32`）
- 方案支持表级别的灵活调整

### 2. 路由表字段差异

| 字段 | 当前实现 | 方案要求 | 说明 |
|------|---------|---------|------|
| `bucket_id` | ✅ | ✅ | 一致 |
| `ds_id` / `ds_name` | ✅ (`ds_name`) | ✅ (`ds_id`) | 字段名不同，功能一致 |
| `tbl_id` | ❌ | ✅ | **需添加** |
| `version` | ❌ | ✅ | **需添加**（当前用 `updated_at`） |
| `status` | ✅ | ✅ | 一致 |
| `target_ds_id` | ❌ | ✅ | **需添加** |
| `target_tbl_id` | ❌ | ✅ | **需添加** |

### 3. ShardingSphere 集成方式

**当前实现**：
- 分片算法是纯函数，不依赖 Spring Bean
- 无法访问 `ProductRouteCache`

**方案要求**：
- 分片算法需要访问 `BucketMappingCache`
- 需要通过 SPI + Spring Context Holder

**解决方案**：
```java
// 方案中的 SpringContextHolder
@Component
public class SpringContextHolder implements ApplicationContextAware {
    private static ApplicationContext context;
    
    public static <T> T getBean(Class<T> clazz) {
        return context.getBean(clazz);
    }
}

// 在分片算法中使用
private BucketMappingCache mappingCache;

@Override
public void init(Properties props) {
    this.mappingCache = SpringContextHolder.getBean(BucketMappingCache.class);
}
```

---

## 实施优先级

### 🔴 高优先级（必须实现）

1. **扩展路由表结构**（添加 `tbl_id`, `version`, `target_ds_id`, `target_tbl_id`）
2. **改造 ShardingSphere 分片算法**（使用路由表而非纯函数）
3. **扩展 ProductRouteCache**（添加表路由缓存）

### 🟡 中优先级（建议实现）

4. **添加 bucket_id 字段**（便于迁移）
5. **实现自动填充拦截器**（自动填充 bucket_id）

### 🟢 低优先级（可选）

6. **迁移状态支持**（双写、迁移工具）
7. **监控告警**（迁移监控）

---

## 风险评估

### 1. 性能风险

**当前**：纯函数计算，性能最好（纳秒级）

**方案**：查缓存，性能略差（微秒级）

**评估**：✅ **低风险**
- 缓存查询性能很好（ConcurrentHashMap）
- 性能差异可忽略（微秒级 vs 纳秒级）

### 2. 可用性风险

**当前**：纯函数，不依赖外部资源

**方案**：依赖路由表和缓存

**评估**：⚠️ **中等风险**
- 需要确保路由缓存初始化成功
- 需要处理缓存刷新失败的情况
- **已有降级策略**：刷新失败时使用旧缓存

### 3. 兼容性风险

**当前**：使用 `product_shard_id % 3` 和 `product_shard_id % 32`

**方案**：使用映射表路由

**评估**：✅ **低风险**
- 初始映射与当前算法一致（`bucket_id % 3` 和 `bucket_id % 32`）
- 可以平滑切换

---

## 迁移方案

### 平滑切换步骤

1. **准备阶段**
   - 扩展路由表结构
   - 初始化路由数据（与当前算法一致）
   - 验证路由数据正确性

2. **灰度切换**
   - 部署新版本代码（支持路由表）
   - 验证新版本路由正确性
   - 逐步切换流量

3. **全量切换**
   - 确认无问题后全量切换
   - 监控路由性能
   - 清理旧代码

---

## 总结

### 当前项目优势

1. ✅ 已有虚拟桶基础设施（1024个bucket）
2. ✅ 已有路由表和缓存机制
3. ✅ 已有版本号刷新机制

### 需要改进的地方

1. ❌ 路由表缺少表路由字段
2. ❌ ShardingSphere 未使用路由表
3. ❌ 缺少迁移状态支持
4. ❌ 缺少 bucket_id 字段

### 实施建议

**建议采用方案**，因为：
1. ✅ 当前项目已有 70% 的基础设施
2. ✅ 只需要扩展和完善，不需要重写
3. ✅ 可以平滑迁移，风险可控
4. ✅ 支持灵活的扩容和迁移

**预计工作量**：10-15 天（包括测试）


