# 渠道库存隔离方案设计（P7 级别）

## 一、问题分析

### 1.1 核心问题

**场景**：
- POS 渠道设置库存限制 10 份
- KIOSK 渠道设置库存限制 10 份
- 总库存只有 15 份
- 如何防止超卖？

**关键点**：
1. **总库存共享**：所有渠道共享总库存
2. **渠道状态独立**：每个渠道可以独立设置状态（可售/售罄/库存限制）
3. **扣减时检查**：扣减前检查总库存和渠道状态

---

## 二、数据库设计

### 2.1 方案一：共享库存 + 渠道状态（推荐）

```sql
-- 库存主表（总库存）
CREATE TABLE inventory (
    id BIGINT PRIMARY KEY,
    product_id BIGINT,
    store_id BIGINT,
    total_stock INT,           -- 总库存
    locked_stock INT,          -- 锁定库存
    current_stock INT,          -- 当前库存 = total_stock - locked_stock
    INDEX idx_product_store (product_id, store_id)
);

-- 渠道库存状态表（渠道状态）
CREATE TABLE channel_inventory (
    id BIGINT PRIMARY KEY,
    inventory_id BIGINT,       -- 关联 inventory.id
    channel_code VARCHAR(32),  -- POS, KIOSK, ONLINE_ORDER
    stock_status INT,          -- 1:可售, 2:售罄
    stock_type INT,            -- 1:不限量, 2:限量
    limited_stock INT,         -- 渠道库存限制（可选）
    INDEX idx_inventory_channel (inventory_id, channel_code)
);
```

**设计思路**：
- `inventory` 表存储**总库存**（所有渠道共享）
- `channel_inventory` 表存储**渠道状态**（每个渠道独立）
- 扣减时检查总库存和渠道状态

---

### 2.2 方案二：渠道独立库存（不推荐）

```sql
-- 每个渠道独立库存
CREATE TABLE channel_inventory (
    id BIGINT PRIMARY KEY,
    product_id BIGINT,
    store_id BIGINT,
    channel_code VARCHAR(32),
    stock INT,                 -- 渠道独立库存
    INDEX idx_product_store_channel (product_id, store_id, channel_code)
);
```

**问题**：
- 无法保证总库存不超卖
- 需要复杂的库存分配逻辑
- 不适合共享库存的场景

---

## 三、扣减逻辑设计

### 3.1 核心逻辑

```java
@Transactional
public void deductStock(Long productId, Long storeId, String channelCode, Integer quantity) {
    // 1. 查询总库存
    Inventory inventory = inventoryMapper.selectByProductIdAndStoreId(productId, storeId);
    if (inventory == null) {
        throw new RuntimeException("库存不存在");
    }
    
    // 2. 查询渠道状态
    ChannelInventory channelInventory = channelInventoryMapper
        .selectByInventoryIdAndChannel(inventory.getId(), channelCode);
    if (channelInventory == null) {
        throw new RuntimeException("渠道库存不存在");
    }
    
    // 3. 检查渠道状态
    if (channelInventory.getStockStatus() == OUT_OF_STOCK) {
        throw new InsufficientStockException("渠道已售罄");
    }
    
    // 4. 检查总库存
    int availableStock = inventory.getCurrentStock() - inventory.getLockedStock();
    if (availableStock < quantity) {
        throw new InsufficientStockException("总库存不足");
    }
    
    // 5. 检查渠道库存限制（如果设置了）
    if (channelInventory.getStockType() == LIMITED) {
        // 计算渠道已扣减数量（需要查询订单表）
        int channelDeducted = calculateChannelDeducted(productId, storeId, channelCode);
        int channelAvailable = channelInventory.getLimitedStock() - channelDeducted;
        if (channelAvailable < quantity) {
            throw new InsufficientStockException("渠道库存限制不足");
        }
    }
    
    // 6. 扣减总库存（原子操作）
    int updated = inventoryMapper.deductStock(
        inventory.getId(), 
        quantity,
        inventory.getLockedStock()  // 当前 locked_stock
    );
    if (updated == 0) {
        throw new InsufficientStockException("库存扣减失败，可能已被其他操作修改");
    }
    
    // 7. 记录渠道扣减（用于统计）
    channelDeductLogMapper.insert(productId, storeId, channelCode, quantity);
}
```

---

### 3.2 数据库扣减 SQL

```sql
-- 扣减总库存（原子操作）
UPDATE inventory 
SET current_stock = current_stock - #{quantity},
    locked_stock = locked_stock - #{quantity},
    updated_at = NOW()
WHERE id = #{inventoryId}
  AND locked_stock >= #{quantity}  -- 防止超卖
  AND current_stock - locked_stock >= #{quantity}  -- 检查可用库存
```

---

## 四、问题解答

### 4.1 问题1：如何防止超卖？

**答案**：

```
场景：POS 设置 10 份，KIOSK 设置 10 份，总库存 15 份

方案：
1. 总库存共享：所有渠道共享 15 份总库存
2. 渠道状态独立：每个渠道可以设置库存限制（10 份）
3. 扣减时检查：
   - 检查总库存是否足够（15 份）
   - 检查渠道库存限制是否足够（10 份）
   - 取两者的最小值作为实际可扣减数量

实际可扣减数量 = min(总库存可用, 渠道库存限制可用)
```

**代码实现**：

```java
// 计算实际可扣减数量
int totalAvailable = inventory.getCurrentStock() - inventory.getLockedStock();
int channelAvailable = channelInventory.getLimitedStock() - channelDeducted;
int actualAvailable = Math.min(totalAvailable, channelAvailable);

if (actualAvailable < quantity) {
    throw new InsufficientStockException("库存不足");
}
```

---

### 4.2 问题2：如何保证公平分配？

**答案**：

```
场景：POS 扣减了 8 份，KIOSK 还能扣减多少？

方案：
1. 总库存剩余：15 - 8 = 7 份
2. KIOSK 渠道限制：10 份
3. KIOSK 已扣减：0 份
4. KIOSK 可扣减：min(7, 10 - 0) = 7 份

所以 KIOSK 最多还能扣减 7 份（受总库存限制）
```

**公平性保证**：

```java
// 方案1：先到先得（当前方案）
// 谁先扣减，谁就能扣减更多
// 优点：简单，性能好
// 缺点：可能不公平

// 方案2：按比例分配（复杂）
// 每个渠道按比例分配总库存
// 优点：公平
// 缺点：复杂，性能差

// 方案3：预留库存（推荐）
// 每个渠道预留一定库存
// 优点：公平，简单
// 缺点：可能浪费库存
```

**预留库存方案**：

```sql
-- 渠道库存表增加预留字段
CREATE TABLE channel_inventory (
    ...
    reserved_stock INT,  -- 预留库存
    ...
);

-- 扣减逻辑
int totalAvailable = inventory.getCurrentStock() - inventory.getLockedStock();
int channelReserved = channelInventory.getReservedStock();
int channelAvailable = Math.min(
    totalAvailable - channelReserved,  -- 总库存减去预留
    channelInventory.getLimitedStock() - channelDeducted  -- 渠道限制减去已扣减
);
```

---

### 4.3 问题3：渠道售罄，其他渠道还能卖吗？

**答案**：

```
场景：POS 渠道设置售罄，但总库存还有剩余

方案：
1. 渠道状态独立：POS 售罄不影响其他渠道
2. 扣减时检查：只检查当前渠道的状态
3. 其他渠道可以继续卖（如果总库存足够）

逻辑：
- POS 渠道：stock_status = OUT_OF_STOCK → 不能卖
- KIOSK 渠道：stock_status = IN_STOCK → 可以卖（如果总库存足够）
```

**代码实现**：

```java
// 扣减时只检查当前渠道状态
if (channelInventory.getStockStatus() == OUT_OF_STOCK) {
    throw new InsufficientStockException("当前渠道已售罄");
}

// 不检查其他渠道状态
// 其他渠道可以独立设置状态
```

---

## 五、并发控制

### 5.1 分布式锁

```java
public void deductStock(Long productId, Long storeId, String channelCode, Integer quantity) {
    String lockKey = "stock:lock:" + productId + ":" + storeId;
    
    // 1. 获取分布式锁
    if (redisLock.tryLock(lockKey, 5, TimeUnit.SECONDS)) {
        try {
            // 2. 查询库存
            Inventory inventory = inventoryMapper.selectByProductIdAndStoreId(...);
            ChannelInventory channelInventory = channelInventoryMapper.selectByInventoryIdAndChannel(...);
            
            // 3. 检查库存
            if (checkStock(inventory, channelInventory, quantity)) {
                // 4. 扣减库存
                inventoryMapper.deductStock(...);
            }
        } finally {
            redisLock.unlock(lockKey);
        }
    } else {
        throw new LockException("获取锁失败，请重试");
    }
}
```

---

### 5.2 数据库行锁

```sql
-- 使用 SELECT ... FOR UPDATE
BEGIN;
SELECT * FROM inventory 
WHERE product_id = ? AND store_id = ? 
FOR UPDATE;

-- 检查库存
-- 扣减库存
UPDATE inventory SET ...;
COMMIT;
```

---

## 六、完整方案总结

### 6.1 数据库设计

```
inventory（总库存）
├── total_stock: 总库存
├── locked_stock: 锁定库存
└── current_stock: 当前库存

channel_inventory（渠道状态）
├── channel_code: 渠道代码
├── stock_status: 渠道状态（可售/售罄）
├── stock_type: 类型（不限量/限量）
└── limited_stock: 渠道库存限制（可选）
```

---

### 6.2 扣减逻辑

```
1. 查询总库存
2. 查询渠道状态
3. 检查渠道状态（售罄则拒绝）
4. 检查总库存（不足则拒绝）
5. 检查渠道库存限制（如果设置了）
6. 计算实际可扣减数量 = min(总库存可用, 渠道限制可用)
7. 扣减总库存（原子操作）
8. 记录渠道扣减日志
```

---

### 6.3 并发控制

```
1. 分布式锁（更新前获取锁）
2. 数据库行锁（SELECT ... FOR UPDATE）
3. WHERE 条件（防止超卖）
```

---

## 七、面试回答模板

### 7.1 问题1：如何防止超卖？

> "我们采用了**共享库存 + 渠道状态独立**的方案：
> 
> **数据库设计**：
> - `inventory` 表存储总库存（所有渠道共享）
> - `channel_inventory` 表存储渠道状态（每个渠道独立）
> 
> **扣减逻辑**：
> - 扣减时检查总库存和渠道库存限制
> - 实际可扣减数量 = min(总库存可用, 渠道限制可用)
> - 使用数据库 WHERE 条件防止超卖
> 
> **示例**：
> - POS 设置 10 份，KIOSK 设置 10 份，总库存 15 份
> - POS 扣减时：min(15, 10) = 10 份（受渠道限制）
> - KIOSK 扣减时：min(15-10, 10) = 5 份（受总库存限制）"

---

### 7.2 问题2：如何保证公平分配？

> "我们采用了**先到先得 + 预留库存**的方案：
> 
> **方案1：先到先得**（当前方案）
> - 谁先扣减，谁就能扣减更多
> - 优点：简单，性能好
> - 缺点：可能不公平
> 
> **方案2：预留库存**（推荐）
> - 每个渠道预留一定库存
> - 扣减时：实际可扣减 = min(总库存 - 预留, 渠道限制)
> - 优点：公平，简单
> 
> **示例**：
> - POS 预留 8 份，KIOSK 预留 7 份
> - POS 扣减时：min(15-8, 10) = 7 份
> - KIOSK 扣减时：min(15-7, 10) = 8 份"

---

### 7.3 问题3：渠道售罄，其他渠道还能卖吗？

> "可以，因为**渠道状态独立**：
> 
> **逻辑**：
> - 渠道状态存储在 `channel_inventory` 表，每个渠道独立
> - 扣减时只检查当前渠道的状态
> - 其他渠道可以独立设置状态
> 
> **示例**：
> - POS 渠道：stock_status = OUT_OF_STOCK → 不能卖
> - KIOSK 渠道：stock_status = IN_STOCK → 可以卖（如果总库存足够）
> 
> **代码实现**：
> ```java
> if (channelInventory.getStockStatus() == OUT_OF_STOCK) {
>     throw new InsufficientStockException("当前渠道已售罄");
> }
> // 不检查其他渠道状态
> ```"

---

## 八、总结

### 8.1 核心方案

**数据库设计**：
- 共享库存 + 渠道状态独立

**扣减逻辑**：
- 检查总库存和渠道限制
- 取最小值作为实际可扣减数量

**并发控制**：
- 分布式锁 + 数据库行锁 + WHERE 条件

### 8.2 面试价值

| 问题 | 难度 | 重要性 | 面试价值 |
|-----|------|--------|---------|
| **如何防止超卖** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **如何保证公平分配** | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **渠道售罄其他渠道还能卖吗** | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
