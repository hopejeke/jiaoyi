# 订单表虚拟桶路由表方案实施进度

## ✅ 已完成

### 1. 扩展路由表结构
- ✅ 创建升级 SQL：`upgrade_shard_bucket_route.sql`
- ✅ 添加字段：`tbl_id`, `version`, `target_ds_id`, `target_tbl_id`
- ✅ 初始化表路由数据（`bucket_id % 32`）

### 2. 扩展 RouteCache
- ✅ 添加表路由缓存：`tableRouteMap`
- ✅ 添加版本号缓存：`versionMap`
- ✅ 添加迁移目标缓存：`migrationTargetMap`
- ✅ 更新加载逻辑（全量和增量）
- ✅ 添加新方法：`getTableId()`, `isMigrating()`, `getMigrationTarget()`, `getVersion()`

### 3. 创建 SpringContextHolder
- ✅ 实现 `SpringContextHolder` 工具类
- ✅ 支持在非 Spring 管理的类中获取 Bean

### 4. 创建新的分片算法
- ✅ `StoreIdDatabaseShardingAlgorithmV2`（使用路由表）
- ✅ `StoreIdTableShardingAlgorithmV2`（使用路由表）
- ✅ 支持降级为取模算法（`fallback-to-mod`）
- ✅ 支持迁移状态（MIGRATING 时返回源库/源表）

### 5. 注册 SPI
- ✅ 创建 SPI 注册文件：`META-INF/services/org.apache.shardingsphere.sharding.spi.ShardingAlgorithm`

### 6. 更新 ShardingSphere 配置
- ✅ 添加新算法配置（V2 版本）
- ✅ 保留旧算法配置（兼容模式）

---

## 📋 待执行步骤

### 步骤1：执行 SQL 升级路由表

```sql
-- 执行升级脚本
SOURCE order-service/src/main/resources/sql/upgrade_shard_bucket_route.sql;
```

**验证**：
```sql
-- 检查字段是否存在
DESC shard_bucket_route;

-- 验证表路由分布
SELECT ds_name, tbl_id, COUNT(*) as bucket_count
FROM shard_bucket_route
GROUP BY ds_name, tbl_id
ORDER BY ds_name, tbl_id;
```

### 步骤2：重启应用验证

1. 重启应用
2. 检查日志：
   - `RouteCache` 初始化成功（包含表路由）
   - `SpringContextHolder` 初始化成功
   - 新分片算法加载成功

3. 验证路由：
   - 插入订单数据，检查是否正确路由
   - 检查路由是否使用路由表（而不是取模）

### 步骤3：灰度切换（可选）

如果需要平滑切换，可以：

1. **阶段1**：部署新代码，但配置使用旧算法（`store_id_database_old`）
2. **阶段2**：验证新代码无问题后，切换配置使用新算法（`store_id_database`）
3. **阶段3**：观察一段时间，确认无问题后移除旧算法

---

## 🔍 验证清单

### 功能验证

- [ ] 路由表升级成功（字段存在）
- [ ] 路由缓存加载成功（1024 条路由）
- [ ] 表路由缓存加载成功（1024 条）
- [ ] 新分片算法注册成功
- [ ] 数据路由正确（库和表）

### 性能验证

- [ ] 路由查询性能（应该很快，使用缓存）
- [ ] 插入性能（无额外开销）
- [ ] 缓存刷新性能（增量刷新）

### 兼容性验证

- [ ] 降级功能（路由表不可用时降级为取模）
- [ ] 迁移状态（MIGRATING 时返回源库）

---

## 📝 注意事项

1. **执行顺序**：
   - 先执行路由表升级 SQL
   - 再重启应用

2. **回滚方案**：
   - 如果新算法有问题，可以切换回旧算法（`store_id_database_old`）
   - 路由表字段可以保留（不影响旧算法）

3. **性能影响**：
   - 路由查询使用缓存，性能影响可忽略
   - 与商品表方案一致

---

## 🎯 下一步

1. **执行 SQL 脚本**（路由表升级）
2. **重启应用验证**
3. **测试路由功能**
4. **准备扩容迁移方案**（如果需要）

---

## 📊 对比：商品表 vs 订单表

| 维度 | 商品表 | 订单表 |
|------|--------|--------|
| **路由表** | `product_shard_bucket_route` | `shard_bucket_route` |
| **路由缓存** | `ProductRouteCache` | `RouteCache` |
| **分片键** | `product_shard_id` | `store_id`（内部计算 `shard_id`） |
| **数据库算法** | `ProductShardIdDatabaseShardingAlgorithmV2` | `StoreIdDatabaseShardingAlgorithmV2` |
| **表算法** | `ProductShardIdTableShardingAlgorithmV2` | `StoreIdTableShardingAlgorithmV2` |
| **状态** | ✅ 已实现 | ✅ 已实现 |

**现在两者都使用虚拟桶路由表方案，支持动态扩容！**


