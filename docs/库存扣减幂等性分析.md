# 库存扣减幂等性分析

## 问题

当前项目中，扣库存的 outbox 处理，**库存服务并没有实现幂等性保证**。如果同一个 outbox 任务被处理两次（比如重试），会导致重复扣库存。

## 当前实现分析

### 1. Outbox 层面的保护

**唯一约束：**
```sql
UNIQUE KEY uk_type_biz (type, biz_key)
```

**作用：**
- 确保同一个订单的同一个类型的 outbox 任务只能有一个
- `biz_key` = `orderId`（字符串形式）
- `type` = `"DEDUCT_STOCK_HTTP"`

**限制：**
- ✅ 防止同一个订单创建多个扣库存任务
- ❌ **无法防止同一个任务被重试时重复处理**

**场景：**
```
T1: 创建 outbox 任务（orderId=123, status=NEW）
T2: 处理任务，调用库存服务 → 失败（网络超时）
T3: 任务状态变为 FAILED
T4: 重试机制触发，任务状态变为 NEW
T5: 再次处理任务，调用库存服务 → 成功
T6: 但第一次调用可能已经成功（只是响应超时）→ 重复扣库存！
```

### 2. 库存服务层面的问题

**当前实现：`InventoryService.deductStockBatch()`**

```java
@Transactional
public void deductStockBatch(List<Long> productIds, List<Long> skuIds, 
                            List<Integer> quantities, Long orderId) {
    log.info("批量扣减库存，订单ID: {}, 商品数量: {}", orderId, productIds.size());
    
    // ❌ 没有幂等性检查！
    // ❌ 没有检查该订单是否已经扣过库存
    
    for (int i = 0; i < productIds.size(); i++) {
        deductStock(productIds.get(i), skuIds.get(i), quantities.get(i), orderId);
    }
    
    log.info("批量库存扣减完成");
}
```

**问题：**
- ❌ 没有检查 `orderId` 是否已经扣过库存
- ❌ 没有使用 `idempotencyKey`（虽然请求中有这个字段，但服务端没有使用）
- ❌ 直接执行扣减操作，可能导致重复扣库存

### 3. 库存变动记录表

**表结构：`inventory_transaction`**

```sql
CREATE TABLE inventory_transaction (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    product_id BIGINT NOT NULL,
    order_id BIGINT COMMENT '订单ID（如果是订单相关变动）',
    transaction_type VARCHAR(20) NOT NULL COMMENT '变动类型：IN-入库，OUT-出库，LOCK-锁定，UNLOCK-解锁',
    quantity INT NOT NULL COMMENT '变动数量',
    ...
);
```

**问题：**
- ❌ 没有唯一约束 `UNIQUE KEY (order_id, product_id, sku_id, transaction_type)`
- ❌ 扣库存前没有查询是否已存在该订单的扣库存记录
- ✅ 有 `selectByOrderId()` 方法，但扣库存时没有调用

## 幂等性保证方案

### 方案一：在库存服务中添加幂等性检查（推荐）

**实现步骤：**

1. **在扣库存前检查是否已扣过**

```java
@Transactional
public void deductStockBatch(List<Long> productIds, List<Long> skuIds, 
                            List<Integer> quantities, Long orderId) {
    log.info("批量扣减库存，订单ID: {}, 商品数量: {}", orderId, productIds.size());
    
    // ✅ 幂等性检查：查询该订单是否已经扣过库存
    if (orderId != null) {
        List<InventoryTransaction> existingTransactions = 
            inventoryTransactionMapper.selectByOrderId(orderId);
        
        // 检查是否已有 OUT 类型的扣库存记录
        boolean alreadyDeducted = existingTransactions.stream()
            .anyMatch(t -> t.getTransactionType() == InventoryTransaction.TransactionType.OUT);
        
        if (alreadyDeducted) {
            log.warn("订单 {} 已经扣过库存（幂等性检查），跳过重复扣减", orderId);
            return; // 幂等：已扣过，直接返回
        }
    }
    
    // 执行扣减
    for (int i = 0; i < productIds.size(); i++) {
        deductStock(productIds.get(i), skuIds.get(i), quantities.get(i), orderId);
    }
    
    log.info("批量库存扣减完成");
}
```

2. **优化：使用唯一约束 + INSERT IGNORE**

```sql
-- 在 inventory_transaction 表添加唯一约束
ALTER TABLE inventory_transaction 
ADD UNIQUE KEY uk_order_product_sku_type (
    order_id, 
    product_id, 
    sku_id, 
    transaction_type
);
```

```java
private void recordInventoryTransaction(...) {
    InventoryTransaction transaction = new InventoryTransaction();
    // ... 设置字段
    
    // ✅ 使用 INSERT IGNORE 或 INSERT ... ON DUPLICATE KEY UPDATE
    // 如果已存在，则忽略（幂等）
    try {
        transactionMapper.insert(transaction);
    } catch (DuplicateKeyException e) {
        log.warn("库存变动记录已存在（幂等），订单ID: {}, 商品ID: {}, SKU ID: {}", 
                orderId, productId, skuId);
        // 幂等：已存在，直接返回
        return;
    }
}
```

### 方案二：使用 idempotencyKey（更完善）

**实现步骤：**

1. **创建幂等性日志表**

```sql
CREATE TABLE inventory_deduction_idempotency (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    idempotency_key VARCHAR(255) NOT NULL UNIQUE COMMENT '幂等键（orderId + "-DEDUCT"）',
    order_id BIGINT NOT NULL COMMENT '订单ID',
    product_ids TEXT NOT NULL COMMENT '商品ID列表（JSON）',
    sku_ids TEXT NOT NULL COMMENT 'SKU ID列表（JSON）',
    quantities TEXT NOT NULL COMMENT '数量列表（JSON）',
    status VARCHAR(20) NOT NULL COMMENT '状态：PROCESSING-处理中，SUCCESS-成功，FAILED-失败',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_order_id (order_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='库存扣减幂等性日志表';
```

2. **在扣库存前检查幂等性**

```java
@Transactional
public void deductStockBatch(List<Long> productIds, List<Long> skuIds, 
                            List<Integer> quantities, Long orderId,
                            String idempotencyKey) {
    log.info("批量扣减库存，订单ID: {}, idempotencyKey: {}", orderId, idempotencyKey);
    
    // ✅ 幂等性检查：尝试插入幂等性日志
    if (idempotencyKey != null) {
        boolean isFirstRequest = idempotencyLogMapper.tryInsert(
            idempotencyKey, orderId, productIds, skuIds, quantities);
        
        if (!isFirstRequest) {
            log.warn("重复请求（幂等性检查），idempotencyKey: {}, 订单ID: {}", 
                    idempotencyKey, orderId);
            return; // 幂等：已处理过，直接返回
        }
    }
    
    // 执行扣减
    try {
        for (int i = 0; i < productIds.size(); i++) {
            deductStock(productIds.get(i), skuIds.get(i), quantities.get(i), orderId);
        }
        
        // 更新幂等性日志为成功
        if (idempotencyKey != null) {
            idempotencyLogMapper.updateStatus(idempotencyKey, "SUCCESS");
        }
    } catch (Exception e) {
        // 更新幂等性日志为失败
        if (idempotencyKey != null) {
            idempotencyLogMapper.updateStatus(idempotencyKey, "FAILED");
        }
        throw e;
    }
}
```

### 方案三：在 Outbox Handler 中添加幂等性检查

**实现步骤：**

在 `DeductStockHttpOutboxHandler` 中，调用库存服务前先检查：

```java
@Override
public void handle(Outbox outbox) throws Exception {
    DeductStockCommand command = objectMapper.readValue(outbox.getPayload(), DeductStockCommand.class);
    
    // ✅ 幂等性检查：查询该订单是否已经扣过库存
    if (command.getOrderId() != null) {
        List<InventoryTransaction> transactions = 
            productServiceClient.getInventoryTransactionsByOrderId(command.getOrderId());
        
        boolean alreadyDeducted = transactions.stream()
            .anyMatch(t -> "OUT".equals(t.getTransactionType()));
        
        if (alreadyDeducted) {
            log.warn("订单 {} 已经扣过库存（幂等性检查），跳过 outbox 任务处理", 
                    command.getOrderId());
            return; // 幂等：已扣过，直接返回
        }
    }
    
    // 调用库存服务
    ProductServiceClient.DeductStockBatchRequest request = ...;
    productServiceClient.deductStockBatch(request);
}
```

## 推荐方案

**建议采用方案一 + 方案二的组合：**

1. **短期方案（方案一）**：在 `deductStockBatch` 方法中添加幂等性检查
   - 查询 `inventory_transaction` 表，检查是否已有该订单的扣库存记录
   - 如果已存在，直接返回（幂等）

2. **长期方案（方案二）**：创建专门的幂等性日志表
   - 使用 `idempotencyKey` 作为唯一键
   - 在扣库存前检查，确保同一请求只处理一次

## 当前风险

**如果同一个 outbox 任务被处理两次，会导致：**
- ❌ 重复扣库存
- ❌ 库存数量错误
- ❌ 库存变动记录重复
- ❌ 可能导致超卖问题

## 总结

当前项目的库存扣减**没有实现幂等性保证**，需要添加幂等性检查机制，防止重复扣库存。


