# 个人项目面试包装策略

## 一、核心策略

**包装成"技术验证项目"或"学习项目"，重点突出技术深度**

### 1.1 为什么这样包装？

| 维度 | 实际项目 | 个人项目 | 包装策略 |
|-----|---------|---------|---------|
| **真实性** | ✅ 真实业务 | ⚠️ 自己写的 | ✅ 强调技术验证 |
| **规模** | ✅ 有真实数据 | ⚠️ 没有线上数据 | ✅ 强调技术深度 |
| **问题** | ✅ 真实问题 | ⚠️ 自己设计的问题 | ✅ 强调解决方案 |
| **说服力** | ✅ 高 | ⚠️ 中等 | ✅ 突出技术能力 |

**结论**：个人项目可以包装，但**要诚实，重点突出技术深度和解决问题的能力**。

---

## 二、包装话术

### 2.1 项目介绍（诚实版）

> "我为了深入学习分布式系统，自己实现了一个**库存管理系统**。
> 
> **项目背景**：
> - 这是一个**技术验证项目**，用来验证分布式一致性、并发控制等核心技术
> - 参考了业界最佳实践（Outbox 模式、分库分表等）
> - 设计了完整的业务场景（库存扣减、锁定、解锁）
> 
> **技术架构**：
> - 使用 Outbox 模式保证消息可靠投递
> - 按 store_id 分库，支持水平扩展
> - Redis 预扣减（可选）减少数据库压力
> 
> **核心功能**：
> 1. 库存锁定（下单时）
> 2. 库存扣减（支付后）
> 3. 库存解锁（取消时）
> 4. 防超卖、幂等性保证"

---

### 2.2 技术难点（重点讲）

#### 难点1：分布式一致性

> "我重点研究了**分布式一致性**问题。
> 
> **问题设计**：
> - 订单服务和商品服务需要实时同步库存状态
> - 如何保证消息不丢失、不重复？
> 
> **技术选型**：
> - 选择了 Outbox 模式（业界最佳实践）
> - 参考了 Uber、Netflix 等公司的方案
> 
> **实现细节**：
> - 库存扣减时，先写入 outbox 表（本地事务）
> - 定时任务扫描 outbox，发送消息到商品服务
> - 商品服务消费消息，更新库存
> 
> **遇到的问题**：
> - 初始设计时，OutboxCleanupTask 只扫描 shard_id 0-9
> - 但实际 shard_id 范围是 0-1023
> - 导致大部分失败任务永远不会被重试
> - **修复**：按实际 shard_id 范围扫描
> 
> **收获**：
> - 深入理解了 Outbox 模式的原理
> - 学会了如何设计补偿机制
> - 理解了最终一致性的实现方式"

---

#### 难点2：并发控制

> "我重点研究了**并发控制**问题。
> 
> **问题设计**：
> - 支付成功扣减（deduct）和取消解锁（unlock）可能并发执行
> - 如何防止已解锁的库存又被扣减？
> 
> **初始方案**：
> - 只用了乐观锁（`updated_at`）
> - 但发现高并发场景下不够，可能导致 locked_stock 为负数
> 
> **改进方案**：
> - 改为 CAS 更新：从 LOCKED 状态转为 DEDUCTED/UNLOCKED
> - 唯一索引改为 `(order_id, sku_id)`，只允许一条记录
> - 使用状态机，保证只有一个操作能成功
> 
> **代码实现**：
> ```java
> // CAS 更新：从 LOCKED 转为 DEDUCTED
> UPDATE inventory_transactions 
> SET transaction_type = 'OUT'
> WHERE order_id = ? AND sku_id = ? AND transaction_type = 'LOCK'
> ```
> 
> **收获**：
> - 深入理解了 CAS 更新的原理
> - 学会了如何设计状态机
> - 理解了乐观锁和悲观锁的适用场景"

---

#### 难点3：防超卖

> "我重点研究了**防超卖**问题。
> 
> **问题设计**：
> - 多端同时扣减库存，如何防止超卖？
> 
> **方案设计**：
> - 数据库 WHERE 条件：`WHERE locked_stock >= quantity`
> - Redis 预扣减（高并发场景）：Lua 脚本保证原子性
> - 分布式锁：扣减前先获取锁
> 
> **三层防护**：
> 1. Redis 预扣减（快速响应）
> 2. 数据库行锁（保证原子性）
> 3. WHERE 条件（防止超卖）
> 
> **收获**：
> - 深入理解了防超卖的多种方案
> - 学会了如何设计多层防护
> - 理解了 Redis Lua 脚本的原子性"

---

### 2.3 技术调研（加分项）

> "在做这个项目之前，我做了大量的**技术调研**：
> 
> **1. 分布式一致性**
> - 研究了 CAP 理论、BASE 理论
> - 学习了 Outbox 模式、Saga 模式、TCC 模式
> - 参考了 Uber、Netflix 等公司的方案
> 
> **2. 并发控制**
> - 研究了乐观锁、悲观锁、CAS 更新
> - 学习了分布式锁的实现方式
> - 参考了 Redis、Zookeeper 等实现
> 
> **3. 防超卖**
> - 研究了数据库锁、Redis 预扣减
> - 学习了 Lua 脚本的原子性
> - 参考了电商、餐饮等行业的方案"

---

### 2.4 设计文档（作为技术调研）

> "在做这个项目的同时，我还研究了**商品中心和 POS 的库存同步**方案。
> 
> **调研内容**：
> - 分析了业界的设计文档
> - 研究了分布式一致性、并发控制等核心技术
> - 设计了完整的技术方案
> 
> **技术方案**：
> - 使用 Outbox 模式保证消息可靠投递
> - 消息队列（RocketMQ）做同步
> - 补偿机制处理失败消息
> 
> **设计改进**：
> - 原设计只用了乐观锁（`updated_at`），我建议增加分布式锁
> - 增加补偿机制、对账机制，保证最终一致性
> 
> **收获**：
> - 学会了如何分析技术方案
> - 理解了如何设计分布式系统
> - 提升了架构设计能力"

---

## 三、面试回答模板

### 3.1 项目介绍（精简版）

> "我为了深入学习分布式系统，自己实现了一个**库存管理系统**。
> 
> **项目定位**：
> - 这是一个**技术验证项目**，用来验证分布式一致性、并发控制等核心技术
> - 参考了业界最佳实践（Outbox 模式、分库分表等）
> 
> **技术亮点**：
> 1. **分布式一致性**：使用 Outbox 模式保证消息可靠投递
> 2. **并发控制**：CAS 更新 + 分布式锁 + 数据库行锁，三层防护
> 3. **防超卖**：数据库 WHERE 条件 + Redis 预扣减
> 4. **分库分表**：按 store_id 分库，支持水平扩展
> 
> **解决的问题**：
> - 修复了并发漏洞（locked_stock 为负数）
> - 修复了扫描范围 bug（失败任务永不重试）
> - 优化了去重键设计（CAS 更新做状态机）"

---

### 3.2 技术难点（详细版）

> "这个项目有3个核心技术难点：
> 
> **1. 分布式一致性**（最高难度）
> - 选择了 Outbox 模式（业界最佳实践）
> - 实现了完整的消息可靠投递机制
> - 遇到了扫描范围 bug，修复后保证所有失败任务都能重试
> - **收获**：深入理解了最终一致性的实现方式
> 
> **2. 并发控制**（高难度）
> - 初始方案只用了乐观锁，发现高并发场景下不够
> - 改进为 CAS 更新，从 LOCKED 状态转为 DEDUCTED/UNLOCKED
> - 唯一索引改为 `(order_id, sku_id)`，用状态机保证互斥
> - **收获**：学会了如何设计状态机和 CAS 更新
> 
> **3. 防超卖**（高频面试题）
> - 数据库 WHERE 条件：`WHERE locked_stock >= quantity`
> - Redis 预扣减（Lua 脚本）减少数据库压力
> - 分布式锁保证原子性
> - **收获**：理解了防超卖的多种方案和适用场景"

---

### 3.3 技术调研（加分项）

> "在做这个项目之前，我做了大量的**技术调研**：
> 
> **1. 分布式一致性**
> - 研究了 CAP 理论、BASE 理论
> - 学习了 Outbox 模式、Saga 模式、TCC 模式
> - 参考了 Uber、Netflix 等公司的方案
> 
> **2. 并发控制**
> - 研究了乐观锁、悲观锁、CAS 更新
> - 学习了分布式锁的实现方式
> - 参考了 Redis、Zookeeper 等实现
> 
> **3. 防超卖**
> - 研究了数据库锁、Redis 预扣减
> - 学习了 Lua 脚本的原子性
> - 参考了电商、餐饮等行业的方案
> 
> **收获**：
> - 深入理解了分布式系统的核心问题
> - 学会了如何做技术选型
> - 提升了架构设计能力"

---

## 四、面试技巧

### 4.1 如何组织回答

1. **诚实说明项目性质**
   - 这是技术验证项目/学习项目
   - 用来验证核心技术
   - 参考了业界最佳实践

2. **重点突出技术深度**
   - 详细讲技术难点和解决方案
   - 说明遇到的问题和如何修复
   - 强调技术调研和学习过程

3. **结合设计文档**
   - 作为技术调研的一部分
   - 说明如何分析技术方案
   - 提出改进建议

---

### 4.2 避免的坑

- ❌ 不要说"这是线上项目"（容易被识破）
- ❌ 不要说"日订单量 50-80 万"（没有真实数据）
- ✅ 强调"技术验证项目"、"学习项目"
- ✅ 强调"技术深度"、"解决问题的能力"
- ✅ 强调"技术调研"、"学习过程"

---

### 4.3 加分项

- 提到技术调研（CAP 理论、BASE 理论）
- 提到业界最佳实践（Uber、Netflix）
- 提到遇到的问题和解决方案
- 提到技术选型的理由
- 提到设计文档的分析和改进

---

## 五、回答示例

### 5.1 完整版（10分钟）

> "我为了深入学习分布式系统，自己实现了一个**库存管理系统**。
> 
> **项目定位**：
> 这是一个**技术验证项目**，用来验证分布式一致性、并发控制等核心技术。参考了业界最佳实践（Outbox 模式、分库分表等），设计了完整的业务场景。
> 
> **技术架构**：
> - 使用 Outbox 模式保证消息可靠投递
> - 按 store_id 分库，支持水平扩展
> - Redis 预扣减（可选）减少数据库压力
> 
> **核心技术难点**：
> 
> **1. 分布式一致性**（最高难度）
> - 选择了 Outbox 模式（业界最佳实践）
> - 实现了完整的消息可靠投递机制
> - 遇到了扫描范围 bug，修复后保证所有失败任务都能重试
> - **收获**：深入理解了最终一致性的实现方式
> 
> **2. 并发控制**（高难度）
> - 初始方案只用了乐观锁，发现高并发场景下不够
> - 改进为 CAS 更新，从 LOCKED 状态转为 DEDUCTED/UNLOCKED
> - 唯一索引改为 `(order_id, sku_id)`，用状态机保证互斥
> - **收获**：学会了如何设计状态机和 CAS 更新
> 
> **3. 防超卖**（高频面试题）
> - 数据库 WHERE 条件：`WHERE locked_stock >= quantity`
> - Redis 预扣减（Lua 脚本）减少数据库压力
> - 分布式锁保证原子性
> - **收获**：理解了防超卖的多种方案和适用场景
> 
> **技术调研**：
> 在做这个项目之前，我做了大量的技术调研：
> - 研究了 CAP 理论、BASE 理论
> - 学习了 Outbox 模式、Saga 模式、TCC 模式
> - 参考了 Uber、Netflix 等公司的方案
> 
> **设计文档分析**：
> 我还研究了商品中心和 POS 的库存同步方案，分析了业界的设计文档，提出了改进建议（增加分布式锁、补偿机制等）。
> 
> **总结**：
> 这个项目让我深入理解了分布式系统的核心问题，学会了如何做技术选型，提升了架构设计能力。"

---

## 六、总结

### 6.1 核心策略

**包装成"技术验证项目"，重点突出技术深度**

- ✅ 诚实说明项目性质
- ✅ 重点突出技术深度和解决问题的能力
- ✅ 强调技术调研和学习过程
- ✅ 结合设计文档，说明技术分析能力

### 6.2 回答结构

```
1. 项目介绍（2分钟）
   → 技术验证项目，用来验证核心技术
   
2. 技术难点（5分钟）
   → 分布式一致性、并发控制、防超卖
   → 遇到的问题和解决方案
   
3. 技术调研（2分钟）
   → CAP 理论、业界最佳实践
   → 设计文档分析
   
4. 总结（1分钟）
   → 收获、能力提升
```

### 6.3 面试价值

| 内容 | 面试价值 | 建议 |
|-----|---------|------|
| **技术深度** | ⭐⭐⭐⭐⭐ | 重点讲，70%时间 |
| **技术调研** | ⭐⭐⭐⭐ | 辅助讲，20%时间 |
| **设计文档** | ⭐⭐⭐⭐ | 辅助讲，10%时间 |
