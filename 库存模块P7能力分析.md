# 库存模块 P7 能力分析报告

## 一、整体评估

本项目库存模块基于 Spring Boot + ShardingSphere + RocketMQ + Redis 构建，实现了电商交易场景下的库存管理核心能力。从 P7 视角审视，该模块**在业务建模和基本并发安全上有一定基础**，但在**系统设计深度、性能优化、分布式一致性保障、可观测性**等 P7 核心考察维度上存在明显的提升空间。

---

## 二、已具备的 P7 亮点（可作为面试加分项讲述）

### 2.1 库存状态机 + CAS 实现扣减/解锁互斥

**对应代码**: `InventoryService.java:320-347` (deductStock), `InventoryService.java:435-462` (unlockStock)

- 通过 `inventory_transactions` 表的 `transaction_type` 字段实现 LOCK -> OUT / LOCK -> UNLOCK 的状态机转换
- 使用 `casUpdateToDeducted()` / `casUpdateToUnlocked()` 做 CAS 更新，保证 deduct 和 unlock 互斥
- **P7 价值**: 能讲清楚"为什么不用分布式锁而用 CAS 状态机"，说明对并发控制方案有权衡

### 2.2 多层幂等保障

**对应代码**: `InventoryService.java:226-251` (事务表幂等), `InventoryService.java:574-612` (幂等键), `DeductStockConsumer.java:68-81` (消费幂等)

三层幂等设计：
1. **SQL 层**: `(order_id, sku_id, transaction_type)` 唯一约束防重
2. **业务层**: `InventoryDeductionIdempotency` 表 + INSERT IGNORE 原子性检查
3. **消费层**: `ConsumerLogService` 消费日志去重

**P7 价值**: 展示了对分布式场景下"至少一次投递"语义的深入理解

### 2.3 分库分表架构设计

**对应代码**: `InventoryMapper.xml`, ShardingSphere 配置

- 基于 `store_id` 分片到 3 库 x 3 表（inventory_0/1/2），理论支撑 1024 个分片
- 分片键贯穿查询和更新操作

**P7 价值**: 有分库分表实战经验，能讲清分片策略选择和路由原理

### 2.4 库存自动恢复功能（领域建模能力）

**对应代码**: `InventoryRestoreTask.java`, `Inventory.java:43-73`

- 三种恢复模式（MANUAL/TOMORROW/SCHEDULED）覆盖真实业务场景：次日售罄恢复、限时抢购后恢复
- CAS 防重复恢复 + `isRestoredToday()` 幂等检查

**P7 价值**: 体现从业务需求到技术方案的全链路设计能力

---

## 三、需要重点提升的 P7 考察维度

### 3.1 【高并发场景】热点库存的性能瓶颈（**最关键的 P7 考点**）

#### 问题分析

当前锁库存核心路径:
```
请求 -> InventoryService.checkAndLockStock() -> 查数据库获取库存 -> 插入事务记录 -> UPDATE inventory SET locked_stock = locked_stock + ? WHERE ...
```

在秒杀/热销场景下，所有请求最终汇聚到**同一行记录的 UPDATE 操作**，会导致：
- **MySQL 行锁争用**: 大量事务排队等待同一行的行锁，TPS 急剧下降
- **数据库连接池耗尽**: 每个请求至少 2 次 DB 查询 + 1 次 INSERT + 1 次 UPDATE

#### P7 方案（面试可以讲的优化思路）

**方案一：Redis 预扣减 + 异步落库**
```
1. 库存数据预加载到 Redis（Hash: inventory:{skuId} -> {stock: 100, locked: 0}）
2. 下单时用 Redis DECR 原子扣减，成功后发 MQ 异步落库
3. 定期对账 Redis vs MySQL 保证最终一致
```
- 优势: 将 MySQL 行锁争用转移到 Redis 内存操作，单机 10w+ QPS
- 风险: Redis 宕机时库存数据丢失，需要兜底方案

**方案二：库存分桶（Inventory Segmentation）**
```
将 SKU 库存 100 拆分为 N 个桶:
  inventory_segment_1: stock=25
  inventory_segment_2: stock=25
  inventory_segment_3: stock=25
  inventory_segment_4: stock=25
请求随机路由到不同桶，减少行锁竞争
```
- 优势: 无需引入新中间件，MySQL 内完成
- 风险: 桶之间的余量不均问题，需要合并回收机制

**方案三：排队削峰（本地缓冲队列）**
```
请求 -> 本地内存队列 -> 批量合并锁库存 -> 一次 UPDATE locked_stock = locked_stock + (sum)
```

#### 当前代码的具体问题

`InventoryService.java:192-201` 中 `checkAndLockStock` 先做 `selectByProductIdWithSku` 查出所有 SKU 列表再 stream filter，**每次锁库存都要全量查一遍 SKU 列表**，高并发下会造成大量冗余查询。应直接用 `selectByStoreIdAndProductIdAndSkuId` 精确查询。

---

### 3.2 【分布式一致性】缓存与数据库的一致性问题

#### 问题分析

**对应代码**: `InventoryService.java:274-275`, `InventoryCacheService.java:87-102`

当前缓存更新策略是**先更新数据库再更新缓存**（Cache-Aside 的变体），但存在问题：

```java
// InventoryService.java:274-275 (checkAndLockStock)
inventory.setLockedStock(inventory.getLockedStock() + quantity);
inventoryCacheService.updateInventoryCache(inventory);
```

1. **并发写导致缓存脏数据**: 线程 A 和线程 B 同时锁库存，A 先完成 DB 更新，B 后完成 DB 更新，但 B 的缓存更新可能先于 A 执行，导致缓存中的 `lockedStock` 是 A 的旧值
2. **缓存 key 设计问题**: `InventoryCacheService.java:72` 缓存 key 是 `inventory:product:{productId}`，但现在已经是 SKU 级别库存，同一商品下多个 SKU 共享一个缓存 key，**缓存互相覆盖**
3. **缓存和 DB 非原子操作**: DB 更新成功后缓存更新失败，会导致缓存中是旧数据

#### P7 方案

1. **写操作后删除缓存而非更新缓存**（Cache-Aside 标准做法），避免并发写的覆盖问题
2. **缓存 key 粒度应为 SKU 级别**: `inventory:sku:{skuId}` 而非 `inventory:product:{productId}`
3. **引入延迟双删**: 更新 DB -> 删缓存 -> 延迟 500ms -> 再删缓存，解决主从延迟期间的读旧数据问题
4. 如果需要强一致，使用 **Redis + Lua 原子扣减**替代 "查缓存 -> 更新缓存" 的非原子操作

---

### 3.3 【分布式锁缺失】定时任务多实例并发问题

#### 问题分析

**对应代码**: `InventoryRestoreTask.java:56-58`, `InventoryRestoreTask.java:145-149`

代码中有多处 `TODO: Redis分布式锁`，但**没有实际实现**。在多实例部署场景下：

- `restoreInventoryTomorrow()` 每个实例都会执行，虽然 SQL CAS 能防止重复恢复，但会造成大量无效的 DB 查询和更新尝试
- `cleanupExpiredRestoreConfig()` 多实例同时执行，虽然无害但浪费资源

#### P7 方案

```java
// 使用 Redisson 分布式锁
RLock lock = redissonClient.getLock("inventory:restore:tomorrow:" + LocalDate.now());
if (lock.tryLock(0, 300, TimeUnit.SECONDS)) {
    try {
        // 执行恢复逻辑
    } finally {
        lock.unlock();
    }
}
```

或使用 **ShedLock** / **xxl-job** 等分布式调度框架替代 Spring `@Scheduled`，天然支持单点执行。

---

### 3.4 【性能隐患】`selectAll()` 全表扫描

#### 问题分析

**对应代码**: `InventoryService.java:777`, `InventoryService.java:1009`, `InventoryController.java:77-81`

在分片表架构下，以下方法会**扫描所有分片的所有数据**：

```java
// InventoryService.java:777 - updateInventory 中用 selectAll 遍历找记录
List<Inventory> allInventories = inventoryMapper.selectAll();
for (Inventory inv : allInventories) {
    if (inv.getId().equals(inventoryId)) { ... }
}

// InventoryService.java:1009 - restoreInventory 同样用 selectAll
List<Inventory> allInventories = inventoryMapper.selectAll();
```

这是**严重的性能问题**：
- 分片表 selectAll 会扫描 3 库 x 3 表 = 9 个表的全部数据
- 随着数据增长，内存和耗时线性增长
- 在定时任务中调用（每个恢复都 selectAll 一次），放大了影响

#### P7 方案

1. 接口设计上要求传入 `storeId`（分片键），使用 `selectByStoreIdAndId` 精确查询
2. 如果确实不知道 storeId，可以建一个**路由表**（非分片表）: `inventory_routing(id, store_id)`，先查路由再查分片表
3. `restoreInventory` 方法中的库存记录已经从 `selectForTomorrowRestore`/`selectForScheduledRestore` 查出来了，不需要在 `restoreInventory` 里再次 selectAll，直接传入完整的 Inventory 对象即可

---

### 3.5 【事务设计】长事务 + 跨服务调用风险

#### 问题分析

**对应代码**: `InventoryService.java:548` (deductStockBatch)

```java
@Transactional
public void deductStockBatch(...) {
    // 1. 查询幂等表
    // 2. INSERT IGNORE 幂等记录
    // 3. 循环 N 次: 查库存 -> CAS 更新事务表 -> UPDATE inventory
    // 4. 更新幂等表为成功
}
```

整个 batch 在一个大事务中，如果订单有 10 个 SKU：
- 持有数据库连接时间长
- 任一 SKU 扣减失败会回滚所有已成功的 SKU
- 事务内做了多次 DB 查询 + 更新，锁持有时间长

#### P7 方案

1. **拆分为单 SKU 事务** + 外层补偿: 每个 SKU 独立事务扣减，如果中间失败，对已扣减的执行补偿回滚
2. 或者使用 **Saga 模式**: 每个 SKU 扣减是一个独立步骤，有对应的补偿操作
3. 至少应该**限制批量大小**，避免单次事务处理过多 SKU

---

### 3.6 【异常处理】错误码不规范 + RuntimeException 滥用

#### 问题分析

**对应代码**: 整个 InventoryService

```java
// 各种错误都是 RuntimeException + 中文消息
throw new RuntimeException("库存记录不存在，ID: " + inventoryId);
throw new RuntimeException("库存扣减失败");
throw new RuntimeException("无法确定 product_shard_id，请确保商品ID有效");
```

问题：
- 没有统一的业务异常体系和错误码
- Controller 层用 try-catch 捕获所有异常返回 400，无法区分参数错误、库存不足、系统错误等
- 下游调用方（order-service）无法根据错误码做差异化处理（比如库存不足应取消订单，系统错误应重试）

#### P7 方案

定义库存领域异常体系：
```java
public enum InventoryErrorCode {
    STOCK_NOT_FOUND("INV_001", "库存记录不存在"),
    INSUFFICIENT_STOCK("INV_002", "库存不足"),
    DUPLICATE_LOCK("INV_003", "重复锁定"),
    ALREADY_DEDUCTED("INV_004", "已扣减"),
    ALREADY_UNLOCKED("INV_005", "已解锁"),
    DEDUCT_UNLOCK_CONFLICT("INV_006", "扣减与解锁冲突"),
    SHARD_ROUTING_FAILED("INV_007", "分片路由失败");
}
```

---

### 3.7 【可观测性】缺少监控指标和告警

#### 问题分析

当前只有 `log.info/warn/error` 日志，缺少：
- 库存操作的 **Metrics** (如: 锁定成功率、扣减耗时 P99、CAS 失败率)
- 关键业务 **告警** (如: locked_stock 为负数、库存恢复连续失败)
- **链路追踪** (orderId 贯穿从下单到扣库存的全链路)

#### P7 方案

```java
// 使用 Micrometer 暴露 Prometheus 指标
@Timed(value = "inventory.lock.duration", description = "库存锁定耗时")
@Counted(value = "inventory.lock.total", description = "库存锁定次数")
public void checkAndLockStock(...) { ... }

// 关键业务指标
Counter.builder("inventory.lock.cas_failure")
    .tag("sku_id", skuId.toString())
    .register(meterRegistry)
    .increment();
```

---

### 3.8 【接口设计】REST API 不符合规范

#### 问题分析

**对应代码**: `InventoryController.java`

- `PUT /update/{inventoryId}` 应为 `PUT /inventory/{inventoryId}`
- `POST /set-stock` 设置库存应该是 `PUT` 语义
- `POST /{productId}/lock` 锁定库存用 `@RequestParam` 传 skuId/quantity/orderId，应该用 RequestBody
- Controller 内定义了大量 static inner class 作为 DTO，应独立到 dto 包

---

## 四、P7 面试高频考点与本项目的映射

| P7 考点 | 本项目可讲的点 | 深度提升方向 |
|---------|-------------|------------|
| **高并发库存扣减** | CAS + 行级锁 + 幂等保障 | Redis 预扣减、库存分桶、排队削峰 |
| **分布式事务** | Outbox + RocketMQ 最终一致性 | Saga 补偿、TCC 对比分析 |
| **缓存一致性** | Redis 缓存 + 30min TTL | 延迟双删、Canal 监听 binlog 更新缓存 |
| **分库分表** | ShardingSphere + store_id 分片 | 分片键选择的权衡、扩容方案、跨片查询优化 |
| **幂等设计** | 三层幂等（SQL 约束 / 业务表 / 消费去重） | Token 机制、幂等框架抽象 |
| **定时任务** | @Scheduled + CAS 防重 | 分布式调度（xxl-job）、分布式锁 |
| **领域建模** | 库存状态机、恢复模式枚举 | DDD 聚合根、领域事件 |
| **系统容量** | 分片支持水平扩展 | 容量评估方法论、压测方案 |

---

## 五、建议优先改进的 Top 5

按照面试加分效果排序：

1. **引入 Redis 预扣减方案**（或至少能在面试中完整讲述方案设计 + 对账机制）
2. **消除 `selectAll()` 全表扫描**，改为分片键精确查询
3. **实现分布式锁**，替换定时任务中的 TODO 注释
4. **修复缓存 key 粒度**（product -> sku），采用删除缓存而非更新缓存
5. **建立统一异常体系 + 业务错误码**，提升跨服务协作的可维护性

---

## 六、总结

该库存模块的业务覆盖面较全（CRUD、锁定/解锁/扣减、自动恢复、缓存管理），适合作为 P7 面试的项目案例。核心优势在于**多层幂等设计**和**CAS 状态机**，这两个点可以展开深入讲解。

主要差距在于：当前实现更接近"功能完备的 P6 级别"，要达到 P7 标准需要在**系统设计的深度**（高并发优化、分布式一致性）和**工程成熟度**（可观测性、异常体系、API 规范）上做显著提升。建议在面试准备中，结合上述 Top 5 改进项，做到"代码实现了基本方案 + 能口头讲清楚更优方案的权衡"。
