# 渠道库存隔离与贡献库存技术设计

## 一、问题背景

在多渠道零售场景中（POS 堂食、KIOSK 自助机、在线外卖），同一门店的同一商品需要在不同渠道间进行库存分配和管理。核心挑战：

1. **渠道间库存隔离** -- 线上高峰期不能把 POS 的库存全部吃掉，导致堂食无货可售
2. **库存利用率最大化** -- 某个渠道卖不动的库存不应被"锁死"，需要流动到需要的渠道
3. **POS 离线一致性** -- POS 断网期间与云端各自独立扣减，联网后如何合并且检测超卖
4. **绝对设置与相对变更冲突** -- 店长手动设库存（绝对值）与系统自动扣减（相对值）并发进行

## 二、整体架构

```
┌──────────────────────────────────────────────────────────────┐
│                    POI 总库存 (real_quantity = 100)            │
│                                                              │
│   ┌──────────┐   ┌──────────┐   ┌──────────┐               │
│   │  POS 渠道 │   │ KIOSK渠道│   │ 在线渠道  │  ← 渠道配额   │
│   │  quota:30│   │ quota:20 │   │ quota:30 │  （预留实例）  │
│   │  sold:25 │   │ sold:5   │   │ sold:28  │               │
│   │  rate:83%│   │ rate:25% │   │ rate:93% │  ← 水位线     │
│   └────┬─────┘   └────┬─────┘   └────┬─────┘               │
│        │              │              │                       │
│   ┌────▼──────────────▼──────────────▼─────┐                │
│   │         共享池 (shared_pool: 20)         │  ← 弹性库存   │
│   │   任何渠道额度不够时可以借用（按需实例）    │  （按需实例）  │
│   └────────────────────────────────────────┘                │
│                                                              │
│   贡献追踪:                                                   │
│     POS:   borrowed=0,  contributed=5   (净贡献: +5)         │
│     KIOSK: borrowed=0,  contributed=10  (净贡献: +10) ← 空闲  │
│     在线:  borrowed=12, contributed=0   (净贡献: -12) ← 紧张  │
└──────────────────────────────────────────────────────────────┘
```

## 三、核心技术点（面试可展开的 P7 级能力）

### 3.1 渠道库存隔离 + 共享池弹性借调

**技术类比**: 云计算资源调度模型（Reserved Instance + On-Demand Instance）

| 概念 | 类比 | 实现 |
|------|------|------|
| 渠道配额 (channel_quota) | 预留实例 | 按权重预分配固定额度 |
| 共享池 (shared_pool) | 按需实例 | 不分配给任何渠道的弹性库存 |
| 借调 (borrow) | 突发容量 | 渠道额度不够时从共享池借用 |
| 回收 (reclaim) | 自动缩容 | 空闲渠道额度自动回收到共享池 |

**扣减核心路径** (三层漏斗):

```
请求 → 渠道额度(channel_quota - channel_sold >= delta)
         │ 成功 → return SUCCESS_FROM_CHANNEL
         │ 失败 ↓
       共享池(shared_pool >= delta)
         │ 成功 → 记录 borrowed_from_pool += delta
         │        return SUCCESS_FROM_SHARED_POOL
         │ 失败 ↓
       OUT_OF_STOCK → 自动售罄标记
```

**关键实现**: `PoiItemStockService.deductByChannel()` + `StandardDeductionStrategy`

**面试追问点**:
- Q: 为什么不直接用总库存扣减，而要做渠道隔离？
- A: 防止渠道间的"库存踩踏"。线上大促时如果不隔离，会把 POS 堂食库存全部吃光。隔离后每个渠道有保底配额，共享池作为弹性缓冲。
- Q: 共享池和渠道配额的比例怎么定？
- A: 初始按历史销售权重分配。共享池保留总库存的 20%（经验值），后续通过贡献度分析自动调整。

---

### 3.2 策略模式 -- 可扩展的扣减策略

**设计模式**: Strategy Pattern

```java
public interface ChannelDeductionStrategy {
    String name();
    ChannelDeductResult deduct(PoiItemStock stock, PoiItemChannelStock channelStock, ChannelDeductRequest request);
}
```

| 策略 | 路径 | 场景 |
|------|------|------|
| `STANDARD_FUNNEL` | 渠道 → 共享池 → 拒绝 | 日常运营（默认） |
| `STRICT_CHANNEL` | 渠道 → 直接拒绝 | 线上线下严格隔离 |
| `SHARED_POOL_FIRST` | 共享池 → 渠道 → 拒绝 | 全渠道大促（双11） |

**策略路由**: 通过 `request.strategyName` 指定，也可以接入配置中心按 brand/poi 路由。

**面试追问点**:
- Q: 为什么不用 if-else 而用策略模式？
- A: 3 个策略 if-else 还能接受，但实际业务中策略会越来越多（VIP 客户优先、地域差异、时段策略等）。策略模式使得新增策略只需要实现接口 + 注册 bean，不需要修改扣减主流程，符合开闭原则。

---

### 3.3 贡献库存 -- 基于贡献度的动态权重调整

**核心思路**: 追踪每个渠道对共享池的"借"和"还"，基于历史数据自动调整权重分配。

**贡献度模型**:
```
净贡献度 = contributed_to_pool - borrowed_from_pool

正数(净贡献者) → 渠道分配过多，权重应调低
负数(净借调者) → 渠道分配不够，权重应调高
```

**权重调整算法** (类似 TCP 拥塞控制的 AIMD):
```
net_contribution_rate = net_contribution / channel_quota
adjustment = -net_contribution_rate × 0.1    // 反向调整
new_weight = old_weight × (1 + adjustment)   // 限幅 [-0.2, +0.2]
归一化: new_weight = new_weight / sum(all_weights)
```

**实现**: `ChannelStockRebalanceService.adjustWeightsByContribution()`

**面试追问点**:
- Q: 为什么用反向调整而不是直接按销售量计算权重？
- A: 渐进调整比剧烈切换更稳定。如果某天线上做促销，销量暴增直接按销量算权重会把大部分配额给线上，第二天促销结束又要调回来。AIMD 式的渐进调整可以平滑过渡，避免权重剧烈波动。

---

### 3.4 水位线动态再平衡

**核心思路**: 周期性检测各渠道使用率，从空闲渠道自动回收额度到共享池。

```
┌─────────────────────────────────────────┐
│              100%                        │
│  ████████████ HIGH_WATERMARK (80%)       │ → 渠道压力大，需要共享池支撑
│  ████████████                            │
│  ████████████                            │
│  ████████████ LOW_WATERMARK (30%)        │ → 渠道空闲，回收50%剩余额度到共享池
│                                          │
│              0%                          │
└─────────────────────────────────────────┘
```

**回收逻辑**:
```
if 渠道使用率 < LOW_WATERMARK(30%):
    回收量 = 渠道剩余额度 × 50%
    if 回收量 >= 1:
        渠道.quota -= 回收量   (CAS: quota - sold >= reclaimAmount)
        共享池 += 回收量
        渠道.contributed_to_pool += 回收量
```

**实现**: `ChannelStockRebalanceService.rebalance()`

**面试追问点**:
- Q: 为什么不把空闲渠道的额度全部回收？
- A: 保留 50% 是为了应对突发流量。如果 KIOSK 渠道当前空闲但中午高峰来了，如果全部回收了就需要完全依赖共享池，不够平稳。保留一半缓冲类似于流量控制中的"预留带宽"。
- Q: 回收操作的并发安全怎么保证？
- A: SQL 使用 CAS 条件 `WHERE (channel_quota - channel_sold) >= reclaimAmount`，保证只回收确实空闲的额度，不会把正在使用的额度回收掉。

---

### 3.5 POS 离线事件回放 + 冲突合并算法

**问题场景**:
```
T1: 店长在 POS 看到库存50，设置为30（ABSOLUTE_SET）
T1~T2: POS 断网，期间线上自动扣了5杯（RELATIVE_DELTA = -5）
T2: POS 恢复网络，上传 T1 的绝对设置
```

如果直接写 30，相当于**丢失了这 5 杯的扣减**。

**冲突合并算法** (类似 Operational Transformation):
```
finalQuantity = newQuantity + sumDeltaSince(operateTime)
             = 30 + (-5)
             = 25
```

**实现步骤**:
1. `SELECT ... FOR UPDATE` 加行锁
2. 检查 `operateTime > lastManualSetTime`（防止处理过期设置）
3. 查询 `SUM(delta) WHERE change_type='RELATIVE_DELTA' AND created_at > operateTime`
4. 合并: `finalQuantity = newQuantity + deltaSinceT1`
5. 强制写入最终值

**实现**: `PoiItemStockService.handleAbsoluteSet()`

**面试追问点**:
- Q: 这个算法有什么局限性？
- A: 依赖 `stock_log` 表记录完整的变更历史。如果日志丢失或被清理，合并结果就不准确。所以日志表的保留策略很重要，至少保留 7 天。
- Q: 和 CRDT 有什么区别？
- A: CRDT（如 G-Counter）适合纯加法/减法的场景，但我们的绝对设置是"覆盖"语义，不能用标准 CRDT。我们的做法更接近 Operational Transformation（OT），核心是"变换操作使其可以在乱序环境下得到正确结果"。

---

### 3.6 超卖检测与补偿

**触发场景**: POS 离线回放后，发现 `real_quantity < 0`

**处理流程**:
```
1. 检测: real_quantity < 0 → 超卖了
2. 记录: oversell_record 表（PENDING 状态）
3. 止损: 强制设库存为 0，标记售罄
4. 人工确认: 店长在后台选择 CONFIRMED/REFUND/RESOLVED
```

**实现**: `PoiItemStockService.detectOversellAfterReplay()`

---

## 四、数据模型

```sql
-- 主库存表
poi_item_stock
├── real_quantity        -- 实时总库存
├── shared_pool_quantity -- 共享池库存
└── last_manual_set_time -- 最后手动设置时间（冲突合并用）

-- 渠道库存表
poi_item_channel_stock
├── channel_code         -- POS / KIOSK / ONLINE_ORDER
├── channel_quota        -- 渠道分配额度
├── channel_sold         -- 渠道已售数量
├── channel_weight       -- 分配权重（0-1）
├── borrowed_from_pool   -- 从共享池借调累计  ← 贡献追踪
├── contributed_to_pool  -- 向共享池贡献累计  ← 贡献追踪
└── utilization_rate     -- 使用率水位线      ← 动态再平衡

-- 变更日志表（事件溯源）
poi_item_stock_log
├── change_type          -- ABSOLUTE_SET / RELATIVE_DELTA / STATUS_CHANGE
├── delta                -- 变更量
├── source               -- POS / CLOUD / POS_OFFLINE
└── order_id             -- 幂等键

-- 超卖记录表
oversell_record
├── oversell_quantity    -- 超卖数量
├── status               -- PENDING → CONFIRMED → REFUND / RESOLVED
└── resolved_by          -- 处理人
```

## 五、技术点总结（面试一句话描述）

| # | 技术点 | 一句话描述 |
|---|--------|----------|
| 1 | 渠道库存隔离 | 类似云计算的预留实例+按需实例模型，渠道配额做隔离保护，共享池做弹性兜底 |
| 2 | 策略模式扣减 | 三种可插拔扣减策略（标准漏斗/严格隔离/共享池优先），通过配置路由到不同场景 |
| 3 | 贡献库存追踪 | 量化每个渠道的借调和贡献量，基于 AIMD 算法自动调整权重，减少人工干预 |
| 4 | 水位线再平衡 | 周期性检测渠道使用率，从空闲渠道回收额度到共享池，最大化库存利用率 |
| 5 | 冲突合并算法 | 类 OT 算法处理绝对设置与相对变更的并发冲突，保证 POS 离线后数据不丢失 |
| 6 | 超卖检测补偿 | 离线回放后自动检测超卖，记录→止损→人工确认的完整闭环 |
| 7 | 事件溯源日志 | 所有库存变更记录完整事件流，支持回放、审计、冲突合并的时间线查询 |

## 六、关键代码入口

| 功能 | 文件 | 方法 |
|------|------|------|
| 渠道扣减(策略模式入口) | `PoiItemStockService.java` | `deductByChannel()` |
| 标准漏斗策略 | `StandardDeductionStrategy.java` | `deduct()` |
| 严格隔离策略 | `StrictChannelStrategy.java` | `deduct()` |
| 共享池优先策略 | `SharedPoolFirstStrategy.java` | `deduct()` |
| 动态再平衡 | `ChannelStockRebalanceService.java` | `rebalance()` |
| 贡献度权重调整 | `ChannelStockRebalanceService.java` | `adjustWeightsByContribution()` |
| 冲突合并算法 | `PoiItemStockService.java` | `handleAbsoluteSet()` |
| POS 离线回放 | `PoiItemStockService.java` | `replayOfflineEvents()` |
| 超卖检测 | `PoiItemStockService.java` | `detectOversellAfterReplay()` |
| 加权分配 | `PoiItemStockService.java` | `allocateChannelQuotas()` |
