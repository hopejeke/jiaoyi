# 库存自动恢复功能 - 并发安全分析

## ⚠️ 并发问题识别

### 1. 多实例重复执行 (CRITICAL)

**问题描述**：
```
实例A (凌晨0点): 查询到100条库存 -> 开始恢复
实例B (凌晨0点): 查询到100条库存 -> 开始恢复
实例C (凌晨0点): 查询到100条库存 -> 开始恢复

结果：同一库存被恢复3次，日志混乱，资源浪费
```

**影响**：
- 数据库压力倍增（3个实例 = 3倍压力）
- 日志重复，难以排查问题
- `last_restore_time` 被重复更新
- 可能导致数据不一致

### 2. 恢复与业务操作并发 (HIGH)

**问题描述**：
```
时间线：
T1: 定时任务读取库存（current_stock=10, locked_stock=5）
T2: 用户下单扣减5件库存 (current_stock=5, locked_stock=0)
T3: 定时任务恢复库存 (current_stock=100) -> 用户订单数据被覆盖！
```

**影响**：
- 用户已支付的订单被覆盖
- 库存数据错误
- 可能导致超卖

### 3. 同一库存重复恢复 (MEDIUM)

**问题描述**：
```
线程A: 查询到库存1（last_restore_time=NULL）
线程B: 查询到库存1（last_restore_time=NULL）
线程A: 更新库存1，设置 last_restore_time=now
线程B: 更新库存1，设置 last_restore_time=now（重复更新）
```

**影响**：
- 库存被重复恢复
- `last_restore_time` 不准确
- 日志混乱

## ✅ 解决方案

### 方案1：应用层并发控制（已实现）

#### 1.1 实例ID标识
```java
// 每个实例启动时生成唯一ID
private final String instanceId = UUID.randomUUID().toString().substring(0, 8);
```
- 日志中包含实例ID，方便排查问题
- 区分不同实例的操作

#### 1.2 今日已恢复检查
```java
private boolean isRestoredToday(Inventory inventory) {
    if (inventory.getLastRestoreTime() == null) {
        return false;
    }
    LocalDateTime today = LocalDateTime.now().toLocalDate().atStartOfDay();
    return inventory.getLastRestoreTime().isAfter(today);
}
```
- 对于TOMORROW模式，每天只恢复一次
- 在恢复前检查，避免重复

#### 1.3 fixedDelay避免任务重叠
```java
@Scheduled(fixedDelay = 300000, initialDelay = 60000)
public void restoreInventoryScheduled() {
    // 上一次执行完成后才开始下一次执行
}
```
- 防止同一实例内任务重叠
- initialDelay延迟启动，避免启动风暴

### 方案2：SQL层CAS更新（已实现）

#### 2.1 原子性更新
```sql
UPDATE inventory SET
    stock_mode = #{stockMode},
    current_stock = #{currentStock},
    last_restore_time = #{lastRestoreTime},
    update_time = NOW()
WHERE id = #{id}
  AND (
      last_restore_time IS NULL
      OR DATE(last_restore_time) < DATE(#{lastRestoreTime})
  )
```

**关键点**：
- `WHERE`条件包含`last_restore_time`检查
- 只有满足条件才更新（CAS - Compare And Set）
- 如果返回0行，说明CAS失败，已被其他线程恢复

#### 2.2 Java层处理CAS失败
```java
int updated = inventoryMapper.restoreInventory(...);

if (updated == 0) {
    log.warn("库存恢复CAS失败（可能已被其他线程恢复），库存ID: {}", inventoryId);
    return; // 不抛异常，正常返回
}
```

### 方案3：分布式锁（推荐用于生产环境）

#### 3.1 使用Redis分布式锁
```java
@Scheduled(cron = "0 5 0 * * ?")
public void restoreInventoryTomorrow() {
    String lockKey = "inventory:restore:tomorrow:" + LocalDateTime.now().toLocalDate();

    // 尝试获取分布式锁（5分钟超时）
    if (!redisLock.tryLock(lockKey, 300)) {
        log.info("其他实例正在执行，跳过本次任务");
        return;
    }

    try {
        // 执行恢复任务
        ...
    } finally {
        redisLock.unlock(lockKey);
    }
}
```

**优点**：
- 多实例部署时，只有一个实例执行
- 避免数据库压力倍增
- 日志清晰，易于排查

**实现建议**：
- 使用Redisson的分布式锁
- 锁超时时间设置合理（建议5-10分钟）
- 确保finally中释放锁

#### 3.2 分布式锁实现示例
```java
@Autowired
private RedissonClient redissonClient;

private boolean tryLock(String lockKey, int timeoutSeconds) {
    RLock lock = redissonClient.getLock(lockKey);
    try {
        return lock.tryLock(0, timeoutSeconds, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return false;
    }
}

private void unlock(String lockKey) {
    RLock lock = redissonClient.getLock(lockKey);
    if (lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}
```

## 📊 并发场景测试

### 场景1：多实例同时启动

**测试步骤**：
1. 启动3个product-service实例
2. 等待凌晨0点
3. 观察日志和数据库

**预期结果**（有分布式锁）：
- 只有1个实例执行任务
- 其他2个实例日志：`其他实例正在执行，跳过本次任务`
- 数据库只更新一次

**预期结果**（无分布式锁，仅CAS）：
- 3个实例都执行任务
- 第一个实例成功恢复100条
- 其他2个实例日志：`库存恢复CAS失败`
- 数据库只更新一次（CAS保证）

### 场景2：恢复时用户下单

**测试步骤**：
1. 设置库存恢复时间为1分钟后
2. 恢复前，用户下单扣减库存
3. 观察库存最终状态

**预期结果**：
- 用户订单扣减的库存不会被恢复覆盖
- 原因：恢复操作是全量设置，不考虑locked_stock
- **建议**：恢复时应考虑locked_stock

**改进方案**：
```java
// 恢复时不覆盖locked_stock
if (inventory.getLockedStock() > 0) {
    log.warn("库存有锁定数量，跳过恢复: inventoryId={}, lockedStock={}",
            inventoryId, inventory.getLockedStock());
    return;
}
```

### 场景3：快速重复点击"设置恢复"

**测试步骤**：
1. 商家快速点击10次"设置恢复"按钮
2. 观察数据库更新次数

**预期结果**：
- 数据库更新10次（符合预期）
- 这不是并发问题，是用户操作

## 🎯 生产环境建议

### 必须实施（已完成）
- ✅ SQL层CAS更新
- ✅ fixedDelay避免任务重叠
- ✅ 实例ID日志标识
- ✅ isRestoredToday检查

### 强烈推荐（需要添加）
- ⚠️ Redis分布式锁（多实例部署必须）
- ⚠️ 恢复前检查locked_stock
- ⚠️ 监控告警（恢复失败数量）

### 可选优化
- 分批处理（每次恢复1000条，避免长时间持锁）
- 恢复前后快照对比（记录恢复前后库存变化）
- 恢复历史表（记录每次恢复操作）

## 📝 分布式锁集成步骤

### 1. 添加依赖
```xml
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-spring-boot-starter</artifactId>
    <version>3.17.7</version>
</dependency>
```

### 2. 配置Redisson
```yaml
spring:
  redis:
    host: localhost
    port: 6379
    database: 0
```

### 3. 修改InventoryRestoreTask
取消注释中的分布式锁代码：
```java
// if (!redisLock.tryLock(lockKey, 300)) {
//     log.info("其他实例正在执行，跳过本次任务");
//     return;
// }
```

改为：
```java
if (!tryLock(lockKey, 300)) {
    log.info("其他实例正在执行，跳过本次任务");
    return;
}
```

## 🔍 监控指标

### 关键指标
- `inventory_restore_success_count`: 恢复成功数量
- `inventory_restore_failed_count`: 恢复失败数量
- `inventory_restore_cas_failed_count`: CAS失败数量（并发冲突）
- `inventory_restore_duration_seconds`: 恢复任务耗时

### 告警规则
- 恢复失败率 > 5%：发送告警
- 恢复任务耗时 > 10分钟：发送告警
- CAS失败数量 > 总数的20%：检查是否多实例未加分布式锁

## 总结

| 问题 | 危险等级 | 解决方案 | 状态 |
|------|---------|---------|------|
| 多实例重复执行 | CRITICAL | Redis分布式锁 | ⚠️ TODO |
| 恢复与业务并发 | HIGH | 检查locked_stock | ⚠️ TODO |
| 同一库存重复恢复 | MEDIUM | SQL CAS更新 | ✅ 已完成 |
| 任务重叠 | LOW | fixedDelay | ✅ 已完成 |

**当前状态**：
- 单实例部署：✅ 安全
- 多实例部署：⚠️ 需要添加分布式锁

**下一步行动**：
1. 如果是多实例部署，立即添加Redis分布式锁
2. 添加locked_stock检查，避免覆盖用户订单
3. 添加监控和告警
